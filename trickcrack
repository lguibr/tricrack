File: page.tsx
"use client";
import { HexGridProvider } from "./contexts/HexGridContext";
import dynamic from "next/dynamic";
const HexGrid = dynamic(() => import("@/app/components/HexGrid"), {
  ssr: false,
});
export default function Home() {
  return (
    <main>
      <HexGridProvider>
        <HexGrid />
      </HexGridProvider>
    </main>
  );
}


File: globals.css
:root {
  --max-width: 1100px;
  --border-radius: 12px;
  --font-mono: ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono",
    "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro",
    "Fira Mono", "Droid Sans Mono", "Courier New", monospace;

  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;

  --primary-glow: conic-gradient(from 180deg at 50% 50%,
      #16abff33 0deg,
      #0885ff33 55deg,
      #54d6ff33 120deg,
      #0071ff33 160deg,
      transparent 360deg);
  --secondary-glow: radial-gradient(rgba(255, 255, 255, 1),
      rgba(255, 255, 255, 0));

  --tile-start-rgb: 239, 245, 249;
  --tile-end-rgb: 228, 232, 233;
  --tile-border: conic-gradient(#00000080,
      #00000040,
      #00000030,
      #00000020,
      #00000010,
      #00000010,
      #00000080);

  --callout-rgb: 238, 240, 241;
  --callout-border-rgb: 172, 175, 176;
  --card-rgb: 180, 185, 188;
  --card-border-rgb: 131, 134, 135;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;

    --primary-glow: radial-gradient(rgba(1, 65, 255, 0.4), rgba(1, 65, 255, 0));
    --secondary-glow: linear-gradient(to bottom right,
        rgba(1, 65, 255, 0),
        rgba(1, 65, 255, 0),
        rgba(1, 65, 255, 0.3));

    --tile-start-rgb: 2, 13, 46;
    --tile-end-rgb: 2, 5, 19;
    --tile-border: conic-gradient(#ffffff80,
        #ffffff40,
        #ffffff30,
        #ffffff20,
        #ffffff10,
        #ffffff10,
        #ffffff80);

    --callout-rgb: 20, 20, 20;
    --callout-border-rgb: 108, 108, 108;
    --card-rgb: 100, 100, 100;
    --card-border-rgb: 200, 200, 200;
  }
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(to bottom,
      transparent,
      rgb(var(--background-end-rgb))) rgb(var(--background-start-rgb));
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}

File: manifest.ts
import { MetadataRoute } from "next";

export default function manifest(): MetadataRoute.Manifest {
  return {
    name: "TriCrack",
    short_name: "TriCrack",
    orientation: "any",
    scope: "/",
    start_url: "/",
    display: "standalone",
    theme_color: "#111",
    background_color: "#222",
    icons: [
      {
        src: "/android-chrome-192x192.png",
        sizes: "192x192",
        type: "image/png",
        purpose: "maskable",
      },
      {
        src: "/android-chrome-512x512.png",
        sizes: "512x512",
        type: "image/png",
      },
    ],
  };
}


File: _app.tsx
import type { AppProps } from "next/app";

export default function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <meta
        name="viewport"
        content="minimum-scale=1, initial-scale=1, width=device-width, shrink-to-fit=no, user-scalable=no, viewport-fit=cover"
      />
      <meta name="application-name" content="tricrack 0.1" />
      <meta name="apple-mobile-web-app-capable" content="yes" />
      <meta name="apple-mobile-web-app-status-bar-style" content="default" />
      <meta name="apple-mobile-web-app-title" content="tricrack 0.1" />
      <meta name="description" content="Best tricrack 0.1 in the world" />
      <meta name="format-detection" content="telephone=no" />
      <meta name="mobile-web-app-capable" content="yes" />
      <meta name="msapplication-config" content="/browserconfig.xml" />
      <meta name="msapplication-TileColor" content="#2B5797" />
      <meta name="msapplication-tap-highlight" content="no" />
      <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
      <link
        rel="apple-touch-icon"
        sizes="152x152"
        href="/apple-touch-icon.png"
      />
      <link
        rel="apple-touch-icon"
        sizes="180x180"
        href="/apple-touch-icon.png"
      />
      <link
        rel="apple-touch-icon"
        sizes="167x167"
        href="/apple-touch-icon.png"
      />
      <link
        rel="icon"
        type="image/png"
        sizes="32x32"
        href="/favicon-32x32.png"
      />
      <link
        rel="icon"
        type="image/png"
        sizes="16x16"
        href="/favicon-16x16.png"
      />
      <link rel="manifest" href="/manifest.json" />
      <link rel="shortcut icon" href="/favicon.ico" />
      <meta name="theme-color" content="#000" />
      <meta name="twitter:card" content="summary" />
      <meta name="twitter:url" content="https://tricrack.luisguilher.me" />
      <meta name="title" content="Tricrack" />
      <meta name="twitter:title" content="Tricrack" />
      <meta name="twitter:description" content="Tricrack" />
      <meta
        name="twitter:image"
        content="https://tricrack.luisguilher.me/android-chrome-192x192.png"
      />
      <meta name="twitter:creator" content="@luisguilher_me" />
      <meta property="og:type" content="website" />
      <meta property="og:title" content="tricrack 0.1" />
      <meta property="og:description" content="Tricrack" />
      <meta property="og:site_name" content="Tricrack" />
      <meta property="og:url" content="https://tricrack.luisguilher.me" />
      <meta
        property="og:image"
        content="https://tricrack.luisguilher.me/apple-touch-icon.png"
      />
      <Component {...pageProps} />;
    </>
  );
}


File: layout.tsx
"use client";

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import StyledComponentsRegistry from "@/lib/registry";
import { Analytics } from "@vercel/analytics/react";
import { useEffect } from "react";

const inter = Inter({ subsets: ["latin"] });

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  let sw: ServiceWorkerContainer | undefined;

  if (typeof window !== "undefined") {
    sw = window?.navigator?.serviceWorker;
  }
  useEffect(() => {
    if (sw) {
      sw.register("/sw.js", { scope: "/" })
        .then((registration) => {
          console.log(
            "Service Worker registration successful with scope: ",
            registration.scope
          );
        })
        .catch((err) => {
          console.log("Service Worker registration failed: ", err);
        });
    }
  }, [sw]);

  return (
    <StyledComponentsRegistry>
      <html lang="en">
        <script src="DragDropTouch.js" async></script>
        <body className={inter.className}>
          <Analytics />
          {children}
        </body>
      </html>
    </StyledComponentsRegistry>
  );
}


File: game/index.tsx
import * as tf from "@tensorflow/tfjs";

import { FixedLengthArray, TriangleState } from "../helpers/types";
import {
  colsPerRowGrid,
  rowsOnGrid,
  colsPerRowShape,
  gridPadding,
} from "../helpers/constants";
import { buildNewShape } from "../helpers/triangles";

import { checkLineCollapse } from "./../game/collapse";

import { isTriangleUp, initializeTrianglesGrid } from "../helpers/triangles";

import { combineMatrices } from "../helpers/calculations";

class Game {
  private historyTriangles: TriangleState[][] = [];
  private historyShapes: TriangleState[][][] = [];
  private historyScores: number[] = [0];
  private highScore: number;

  constructor() {
    this.highScore = parseInt(
      typeof window !== "undefined"
        ? localStorage.getItem("highScore") || "0"
        : "0",
      10
    );

    // Bind methods to this instance
    this.resetGame = this.resetGame.bind(this);
    this.addToScore = this.addToScore.bind(this);
    this.setShape = this.setShape.bind(this);
    this.setTriangles = this.setTriangles.bind(this);
    this.undo = this.undo.bind(this);
    this.getValidPositionsByShapes = this.getValidPositionsByShapes.bind(this);
    this.calculateHoveredAndValidPositions =
      this.calculateHoveredAndValidPositions.bind(this);
    this.getColRowByIndex = this.getColRowByIndex.bind(this);
    this.getTensorGameState = this.getTensorGameState.bind(this);

    this.resetGame();
  }

  public get triangles() {
    return this.historyTriangles[this.historyTriangles.length - 1];
  }

  public get shapes() {
    return this.historyShapes[this.historyShapes.length - 1];
  }

  public get score() {
    return this.historyScores[this.historyScores.length - 1];
  }

  public get currentHighScore() {
    return this.highScore;
  }

  public resetGame() {
    this.historyScores = [0];

    const initialTriangles: TriangleState[] =
      initializeTrianglesGrid(colsPerRowGrid);

    this.historyTriangles = [[...initialTriangles]];
    this.historyShapes = [Array.from({ length: 3 }, () => buildNewShape())];
  }

  public addToScore(points: number) {
    this.historyScores = [
      ...this.historyScores,
      this.historyScores[this.historyScores.length - 1] + points,
    ];
    this.updateHighScore();
  }

  public setShape(index: number, shape: TriangleState[]) {
    const newShapes = [...this.shapes];
    newShapes[index] = shape;
    this.historyShapes = [...this.historyShapes, newShapes];
    this.checkLineCollapse();
    if (this.shapes.flat().length === 0) {
      this.historyShapes.push([
        buildNewShape(),
        buildNewShape(),
        buildNewShape(),
      ]);

      const newHistoryShapes = this.historyShapes?.filter(
        (shapes) => shapes.flat().length > 0
      );

      this.historyShapes = newHistoryShapes;
    }
  }

  public setTriangles(
    action: (prevTriangles: TriangleState[]) => TriangleState[]
  ) {
    const lastTriangles = this.triangles;
    const newTriangles = action(lastTriangles);
    if (
      JSON.stringify(lastTriangles.map((t) => t.color)) !==
      JSON.stringify(newTriangles.map((t) => t.color))
    ) {
      this.historyTriangles = [...this.historyTriangles, newTriangles];
    }
  }

  public undo() {
    if (this.historyTriangles.length > 1 && this.historyShapes.length > 1) {
      let scoreOffset = 1;

      this.historyTriangles = this.historyTriangles.slice(0, -1);
      const collapsedTriangles = checkLineCollapse(this.triangles);
      if (collapsedTriangles.length > 0) {
        scoreOffset = 2;
        this.historyTriangles = this.historyTriangles.slice(0, -1);
      }

      this.historyShapes = this.historyShapes.slice(0, -1);
      this.historyScores = this.historyScores.slice(0, -scoreOffset);
    }
  }

  private updateHighScore() {
    const localStorageScore = parseInt(
      localStorage.getItem("highScore") || "0",
      10
    );
    const currentScore = this.score;
    if (currentScore > localStorageScore) {
      localStorage.setItem("highScore", currentScore.toString());
      this.highScore = currentScore;
    }
  }

  public getValidPositionsByShapes(): { col: number; row: number }[][] {
    return this.shapes.map((shape) => {
      const shapeIsEmtpy = shape.length === 0;
      const validPositions: { row: number; col: number }[] = [];

      this.triangles.forEach((triangle) => {
        const { isValid } = this.calculateHoveredAndValidPositions(
          null,
          triangle,
          true,
          shape
        ) ?? { isValid: false };

        if (isValid)
          validPositions.push({ row: triangle.row, col: triangle.col });
      });

      return validPositions;
    });
  }

  public calculateHoveredAndValidPositions(
    event: React.DragEvent | null,
    targetTriangle: TriangleState,
    isDropEvent = false,
    shape: TriangleState[] | null = null
  ) {
    event?.preventDefault();

    const shapeIsEmpty = !shape || shape?.length === 0;
    if (shapeIsEmpty) return;

    const firstTriangle = shape[0];
    const defaultColOffset = gridPadding[targetTriangle.row];
    const newHoveredTriangles = new Set<string>();
    const validPositions: { row: number; col: number }[] = [];

    const isValid = shape.every((triangle) => {
      const targetRow = targetTriangle.row + triangle.row - firstTriangle.row;
      const targetCol =
        targetTriangle.col +
        triangle.col -
        firstTriangle.col -
        gridPadding[targetRow] +
        defaultColOffset;
      const targetTriangleUp = isTriangleUp(
        { row: targetRow, col: targetCol },
        colsPerRowGrid
      );

      const shapeTriangleUp = isTriangleUp(triangle, colsPerRowShape);

      const validPosition =
        targetRow >= 0 &&
        targetRow < rowsOnGrid &&
        targetCol >= 0 &&
        targetCol < colsPerRowGrid[targetRow] &&
        !this.triangles.find(
          (t) => t.row === targetRow && t.col === targetCol && t.color != null
        ) &&
        targetTriangleUp === shapeTriangleUp;

      if (validPosition) {
        if (isDropEvent) {
          validPositions.push({ row: targetRow, col: targetCol });
        } else {
          newHoveredTriangles.add(`${targetRow}-${targetCol}`);
        }
      }

      return validPosition;
    });

    return { newHoveredTriangles, validPositions, isValid };
  }

  public getColRowByIndex(index: number): [number?, number?] {
    const triangle = this.triangles.find((triangle, i) => i === index);
    return [triangle?.col, triangle?.row];
  }

  private getEmptyGrid(): FixedLengthArray<FixedLengthArray<number, 15>, 8> {
    const emptyGrid = Array.from({ length: 8 }, () =>
      Array.from({ length: 15 }, () => 0)
    ) as FixedLengthArray<FixedLengthArray<number, 15>, 8>;

    return emptyGrid;
  }

  getEmptyShapeGrid(): FixedLengthArray<FixedLengthArray<number, 3>, 2> {
    return [
      [0, 0, 0],
      [0, 0, 0],
    ];
  }

  private getShapesGrid(): FixedLengthArray<
    FixedLengthArray<FixedLengthArray<number, 3>, 2>,
    3
  > {
    const shapesGrid: FixedLengthArray<
      FixedLengthArray<FixedLengthArray<number, 3>, 2>,
      3
    > = [
      this.getEmptyShapeGrid(),
      this.getEmptyShapeGrid(),
      this.getEmptyShapeGrid(),
    ];

    this.shapes.forEach((shape, shapeIndex) => {
      shape.forEach((triangle) => {
        const { row, col } = triangle;
        if (row < 8 && col < 15) {
          shapesGrid[shapeIndex][row][col] = 1;
        }
      });
    });

    return shapesGrid;
  }

  private getGridAvailability(): FixedLengthArray<
    FixedLengthArray<number, 15>,
    8
  > {
    const grid = this.getEmptyGrid();
    this.triangles.forEach((triangle) => {
      const { row, col: paddedCol, color } = triangle;
      const active = color != null;
      const rowOffset = gridPadding[row];
      const realCol = paddedCol + rowOffset;

      grid[row][realCol] = active ? 0 : 1;
    });

    return grid;
  }

  private getGriDownwards(): FixedLengthArray<FixedLengthArray<number, 15>, 8> {
    const grid = this.getEmptyGrid();
    this.triangles.forEach((triangle) => {
      const { row, col: paddedCol } = triangle;
      const isUp = isTriangleUp(triangle, colsPerRowGrid);

      const rowOffset = gridPadding[row];
      const realCol = paddedCol + rowOffset;

      grid[row][realCol] = !isUp ? 1 : 0;
    });

    return grid;
  }
  private getGridUpwards(): FixedLengthArray<FixedLengthArray<number, 15>, 8> {
    const grid = this.getEmptyGrid();
    this.triangles.forEach((triangle) => {
      const { row, col: paddedCol } = triangle;
      const isUp = isTriangleUp(triangle, colsPerRowGrid);

      const rowOffset = gridPadding[row];
      const realCol = paddedCol + rowOffset;

      grid[row][realCol] = isUp ? 1 : 0;
    });

    return grid;
  }

  private getShapesUpwardness(): FixedLengthArray<
    FixedLengthArray<number, 3>,
    2
  > {
    const shapeOrientation = this.getEmptyShapeGrid();
    const placeHolderShape = [
      { row: 0, col: 0, color: 0 },
      { row: 0, col: 1, color: 0 },
      { row: 0, col: 2, color: 0 },
      { row: 1, col: 0, color: 0 },
      { row: 1, col: 1, color: 0 },
      { row: 1, col: 2, color: 0 },
    ];

    placeHolderShape.forEach((triangle) => {
      const { row, col } = triangle;
      if (row < 8 && col < 15) {
        const isUp = isTriangleUp(triangle, colsPerRowShape);
        shapeOrientation[row][col] = isUp ? 1 : 0;
      }
    });

    return shapeOrientation;
  }
  private getShapesDownwards(): FixedLengthArray<
    FixedLengthArray<number, 3>,
    2
  > {
    const shapeOrientation = this.getEmptyShapeGrid();
    const placeHolderShape = [
      { row: 0, col: 0, color: 0 },
      { row: 0, col: 1, color: 0 },
      { row: 0, col: 2, color: 0 },
      { row: 1, col: 0, color: 0 },
      { row: 1, col: 1, color: 0 },
      { row: 1, col: 2, color: 0 },
    ];

    placeHolderShape.forEach((triangle) => {
      const { row, col } = triangle;
      if (row < 8 && col < 15) {
        const isUp = isTriangleUp(triangle, colsPerRowShape);
        shapeOrientation[row][col] = !isUp ? 1 : 0;
      }
    });

    return shapeOrientation;
  }

  private getTensorGridShape(): number[] {
    return [8, 15, 3];
  }
  private getTensorShapeShape(): number[] {
    return [2, 3, 3];
  }

  private getFittableByShapeGrid(): FixedLengthArray<
    FixedLengthArray<FixedLengthArray<number, 15>, 8>,
    3
  > {
    const emptyGrids: FixedLengthArray<
      FixedLengthArray<FixedLengthArray<number, 15>, 8>,
      3
    > = [this.getEmptyGrid(), this.getEmptyGrid(), this.getEmptyGrid()];

    const validPositionsByShapes = this.getValidPositionsByShapes();

    validPositionsByShapes.forEach((positions, positionIndex) =>
      positions.forEach(({ row, col }) => {
        const rowOffset = gridPadding[row];
        const realCol = col + rowOffset;
        emptyGrids[positionIndex][row][realCol] = 1;
      })
    );

    return emptyGrids;
  }

  public getTensorGameState(): [
    [tf.Tensor, tf.Tensor, tf.Tensor, tf.Tensor],
    [tf.Tensor, tf.Tensor, tf.Tensor]
  ] {
    const gridDownwards = this.getGriDownwards();
    const gridUpwards = this.getGridUpwards();

    const gridAvailability = this.getGridAvailability();
    const [fittableByShapeGrid1, fittableByShapeGrid2, fittableByShapeGrid3] =
      this.getFittableByShapeGrid();

    const availabilityChannel = combineMatrices([
      gridAvailability,
      gridDownwards,
      gridUpwards,
    ]);

    const fitShape1Channel = combineMatrices([
      fittableByShapeGrid1,
      gridDownwards,
      gridUpwards,
    ]);

    const fitShape2Channel = combineMatrices([
      fittableByShapeGrid2,
      gridDownwards,
      gridUpwards,
    ]);

    const fitShape3Channel = combineMatrices([
      fittableByShapeGrid3,
      gridDownwards,
      gridUpwards,
    ]);

    const shapesUpwardness = this.getShapesUpwardness();
    const shapesDownwards = this.getShapesDownwards();

    const [shape1Grid, shape2Grid, shape3Grid] = this.getShapesGrid();

    const shape1Channel = combineMatrices([
      shape1Grid,
      shapesDownwards,
      shapesUpwardness,
    ]);
    const shape2Channel = combineMatrices([
      shape2Grid,
      shapesDownwards,
      shapesUpwardness,
    ]);
    const shape3Channel = combineMatrices([
      shape3Grid,
      shapesDownwards,
      shapesUpwardness,
    ]);

    const gridsFeatures = [
      availabilityChannel,
      fitShape1Channel,
      fitShape2Channel,
      fitShape3Channel,
    ];

    const shapesFeatures = [shape1Channel, shape2Channel, shape3Channel];

    const [
      availabilityTensor,
      fitShape1Tensor,
      fitShape2Tensor,
      fitShape3Tensor,
    ] = gridsFeatures.map((grid) => tf.tensor(grid, this.getTensorGridShape()));

    const [shape1Tensor, shape2Tensor, shape3Tensor] = shapesFeatures.map(
      (shape) => tf.tensor(shape, this.getTensorShapeShape())
    );

    return [
      [availabilityTensor, fitShape1Tensor, fitShape2Tensor, fitShape3Tensor],
      [shape1Tensor, shape2Tensor, shape3Tensor],
    ];
  }

  public isGameOver() {
    return (
      this.shapes &&
      this.shapes.flat().length !== 0 &&
      this.shapes
        .filter((shape) => shape.length > 0)
        .every((shape) => !this.canPlaceAnyShape(shape))
    );
  }

  public canPlaceAnyShape(shape: TriangleState[]) {
    return this.triangles.some((triangle) => {
      const { isValid } =
        this.calculateHoveredAndValidPositions(null, triangle, true, shape) ??
        {};
      return isValid;
    });
  }

  public checkLineCollapse() {
    const collapsedTriangles = checkLineCollapse(this.triangles);

    if (collapsedTriangles.length > 0) {
      this.setTriangles((prevTriangles) =>
        prevTriangles.map((triangle) => {
          if (collapsedTriangles.find((t) => t.row === triangle.row)) {
            return {
              ...triangle,
              color: null,
            };
          }
          return triangle;
        })
      );
      this.addToScore(collapsedTriangles.length);
    }
  }

  public moveShapeToTriangle(col: number, row: number, shapeIndex: number) {
    const haveShapes = this.shapes && this.shapes.flat(5).length > 0;
    if (!haveShapes) return;
    const shape = this.shapes[shapeIndex];

    const targetTriangle = this.triangles.find(
      (t) => t.row === row && t.col === col
    );

    if (targetTriangle) {
      const { validPositions, isValid } =
        this.calculateHoveredAndValidPositions(
          null,
          targetTriangle,
          true,
          shape
        ) ?? {};

      if (isValid && shape != null && shape.length > 0) {
        const color = shape[0].color;
        this.addToScore(shape.length);
        this.setTriangles((prevTriangles) =>
          prevTriangles.map((triangle) =>
            validPositions?.some(
              (pos) => pos.row === triangle.row && pos.col === triangle.col
            )
              ? {
                  ...triangle,
                  color,
                }
              : triangle
          )
        );
        this.setShape(shapeIndex, []);
      }
    }
  }
}

export default Game;


File: game/collapse.tsx
import { colsPerRowGrid } from "../helpers/constants";
import { removeDuplicatedTrianglesByColAndRow } from "../helpers/triangles";
import { TriangleState } from "../helpers/types";

const getHorizontalLineActive = (
  triangle: TriangleState,
  triangles: TriangleState[]
): TriangleState[] => {
  if (!isTriangleActivish(triangle)) return [];

  let index = 0;
  let neighborTail = triangle ? triangle.neighborhoodX : null;
  let tail =
    triangles.find(
      (triangle) =>
        triangle.row === neighborTail?.row && triangle.col === neighborTail?.col
    ) ?? null;

  let neighborHead = triangle ? triangle.neighborhoodY : null;

  let head =
    triangles.find(
      (triangle) =>
        triangle.row === neighborHead?.row && triangle.col === neighborHead?.col
    ) ?? null;

  const line = [triangle];

  while ((!!tail || !!head) && index < 100) {
    if (!tail && !head) return line;
    const tailActive = isTriangleActivish(tail);
    const headActive = isTriangleActivish(head);

    if (!tailActive || !headActive) {
      return [];
    }

    if (tail) line.push(tail);
    if (head) line.push(head);

    index += 1;
    neighborTail = tail ? tail.neighborhoodX : null;
    tail =
      triangles.find(
        (triangle) =>
          triangle.row === neighborTail?.row &&
          triangle.col === neighborTail?.col
      ) ?? null;

    neighborHead = head ? head.neighborhoodY : null;

    head =
      triangles.find(
        (triangle) =>
          triangle.row === neighborHead?.row &&
          triangle.col === neighborHead?.col
      ) ?? null;
  }

  return line;
};

const getDiagonalLineActive = (
  triangle: TriangleState,
  triangles: TriangleState[],
  directions: ("neighborhoodX" | "neighborhoodY" | "neighborhoodZ")[]
): TriangleState[] => {
  if (!isTriangleActivish(triangle)) return [];
  let index = 0;
  let neighborTail = triangle ? triangle[directions[index % 2]] : null;
  let tail =
    triangles.find(
      (triangle) =>
        triangle.row === neighborTail?.row && triangle.col === neighborTail?.col
    ) ?? null;

  let neighborHead = triangle ? triangle[directions[(index + 1) % 2]] : null;

  let head =
    triangles.find(
      (triangle) =>
        triangle.row === neighborHead?.row && triangle.col === neighborHead?.col
    ) ?? null;

  let line = [triangle];

  while (!!tail || !!head) {
    if (!tail && !head) return line;

    const tailActive = isTriangleActivish(tail);
    const headActive = isTriangleActivish(head);

    if (!tailActive || !headActive) return [];

    if (tail) line.push(tail);
    if (head) line.push(head);

    index += 1;
    neighborTail = tail ? tail[directions[index % 2]] : null;
    tail =
      triangles.find(
        (triangle) =>
          triangle.row === neighborTail?.row &&
          triangle.col === neighborTail?.col
      ) ?? null;

    neighborHead = head ? head[directions[(index + 1) % 2]] : null;

    head =
      triangles.find(
        (triangle) =>
          triangle.row === neighborHead?.row &&
          triangle.col === neighborHead?.col
      ) ?? null;
  }

  return line;
};
const isTriangleActivish = (triangle: TriangleState | null) =>
  triangle == null || triangle?.color != null;

export const checkLineCollapse = (
  triangles: TriangleState[]
): TriangleState[] => {
  const isFirstRow = (triangle: TriangleState) => triangle.row === 0;
  const isFirstCol = (triangle: TriangleState) => triangle.col === 0;
  const isColOdd = (triangle: TriangleState) => triangle.col % 2 !== 0;

  const isLastRow = (triangle: TriangleState) =>
    triangle.row === colsPerRowGrid.length - 1;

  const trianglesToCheckDiagonal = triangles?.filter(
    (triangle) =>
      (isFirstRow(triangle) && isColOdd(triangle)) ||
      (isLastRow(triangle) && isColOdd(triangle))
  );

  const trianglesToCheckHorizontal = triangles?.filter((triangle) =>
    isFirstCol(triangle)
  );

  const yzLineTriangles = trianglesToCheckDiagonal?.map((triangle) => {
    return getDiagonalLineActive(triangle, triangles, [
      "neighborhoodY",
      "neighborhoodZ",
    ]);
  });

  const zxLineTriangles = trianglesToCheckDiagonal?.map((triangle) =>
    getDiagonalLineActive(triangle, triangles, [
      "neighborhoodZ",
      "neighborhoodX",
    ])
  );

  const horizontalLineTriangles = trianglesToCheckHorizontal?.map((triangle) =>
    getHorizontalLineActive(triangle, triangles)
  );

  const lines = [
    ...(yzLineTriangles ?? []),
    ...(zxLineTriangles ?? []),
    ...(horizontalLineTriangles ?? []),
  ]
    .flat()
    .filter((_) => _ != null);

  const collapsedUniqueTriangles = removeDuplicatedTrianglesByColAndRow(lines);

  return collapsedUniqueTriangles;
};


File: helpers/formatters.ts
export function formatMatrix(matrix: number[][]): string {
  // Determine the maximum width of any number in the matrix for formatting
  const maxNumberWidth = Math.max(
    ...matrix.flat().map((num) => num.toString().length)
  );

  // Format each row and join them with newlines
  const formattedRows = matrix.map((row) => {
    return row
      .map((num) => num.toString().padStart(maxNumberWidth, " "))
      .join("");
  });

  return "\n" + formattedRows.join("\n") + "\n";
}


File: helpers/triangles.ts
import { getRandomColor, getRandomNumber } from "./calculations";
import {
  colsPerRowGrid,
  colsPerRowShape,
  gridPadding,
  rowsOnGrid,
} from "./constants";
import { TriangleState } from "./types";

export const initializeTrianglesGrid = (
  colsPerRowGrid: number[]
): TriangleState[] => {
  const rowsOnGrid = colsPerRowGrid.length;
  const initialTriangles: TriangleState[] = [];
  for (let row = 0; row < rowsOnGrid; row++) {
    const cols = colsPerRowGrid[row];
    for (let col = 0; col < cols; col++) {
      const triangle = {
        row,
        col,
        color: null,
        neighborhoodX: null,
        neighborhoodY: null,
        neighborhoodZ: null,
      };
      initialTriangles.push(triangle);
    }
  }

  initialTriangles.forEach((triangle) => {
    const neighbors = getNeighbors(triangle, initialTriangles, colsPerRowGrid);
    triangle.neighborhoodX = neighbors.X;
    triangle.neighborhoodY = neighbors.Y;
    triangle.neighborhoodZ = neighbors.Z;
  });
  return initialTriangles;
};

export const validateShapePosition = (
  targetTriangle: TriangleState,
  triangles: TriangleState[],
  shape: TriangleState[]
) => {
  const firstTriangle = shape[0];
  const defaultColOffset = gridPadding[targetTriangle.row];
  const newHoveredTriangles = new Set<string>();
  const validPositions: { row: number; col: number }[] = [];

  const isValid = shape.every((triangle) => {
    const targetRow = targetTriangle.row + triangle.row - firstTriangle.row;
    const targetCol =
      targetTriangle.col +
      triangle.col -
      firstTriangle.col -
      gridPadding[targetRow] +
      defaultColOffset;
    const targetTriangleUp = isTriangleUp(
      { row: targetRow, col: targetCol },
      colsPerRowGrid
    );

    const shapeTriangleUp = isTriangleUp(triangle, colsPerRowShape);

    const triangleUpMatch = targetTriangleUp === shapeTriangleUp;

    const isInBorderConstrains =
      targetRow >= 0 &&
      targetRow < rowsOnGrid &&
      targetCol >= 0 &&
      targetCol < colsPerRowGrid[targetRow];

    const isTrianglesGridOccupied = triangles.find(
      (t) => t.row === targetRow && t.col === targetCol && t.color != null
    );

    const validPosition =
      isInBorderConstrains && !isTrianglesGridOccupied && triangleUpMatch;

    return validPosition;
  });

  return { newHoveredTriangles, validPositions, isValid };
};

export const isTriangleUp = (
  triangle: { row: number; col: number },
  colsPerRow: number[]
) => {
  return triangle.row < colsPerRow.length / 2
    ? triangle.col % 2 === 0
    : triangle.col % 2 !== 0;
};

export const getIndexFromColAndRow = (
  col: number,
  row: number,
  colsPerRow: number[]
): number => {
  let index = 0;
  for (let i = 0; i < row; i++) {
    index += colsPerRow[i];
  }
  return index + col;
};

export const getRandomNotEmptyShapeElementIndex = (
  shapes: { row: number; col: number }[][]
): number => {
  const shapeIndex = getRandomNumber(0, shapes.length - 1);
  const selectedShape = shapes[shapeIndex];

  if (selectedShape.length === 0)
    return getRandomNotEmptyShapeElementIndex(shapes);
  return shapeIndex;
};

export const removeDuplicatedTrianglesByColAndRow = <
  T extends { col: number; row: number }
>(
  triangles: T[]
): T[] => {
  const triangleMap = new Map<string, T>();

  triangles.forEach((triangle: T) => {
    const key = `${triangle?.row}-${triangle?.col}`;
    triangleMap.set(key, triangle);
  });

  return Array.from(triangleMap.values());
};

export const getNeighbors = (
  triangle: TriangleState,
  triangles: TriangleState[],
  colsPerRow: number[]
) => {
  const { row, col } = triangle;
  const neighborOffsets = getNeighborOffsets(row, col, colsPerRow);

  const neighbors = neighborOffsets
    .map(([rowOffset, colOffset]) => {
      const neighborRow = row + rowOffset;
      const neighborCol = col + colOffset;

      return triangles.find(
        (triangle) =>
          triangle.row === neighborRow && triangle.col === neighborCol
      );
    })
    .filter((neighbor) => neighbor !== null);

  return {
    X: neighbors[0] || null,
    Y: neighbors[1] || null,
    Z: neighbors[2] || null,
  };
};

export const getNeighborOffsets = (
  row: number,
  col: number,
  colsPerRow: number[]
) => {
  const maxCols = Math.max(...colsPerRow);
  const padding = colsPerRow.map((cols) => (maxCols - cols) / 2);
  const currentTowColpadding = padding[row];

  const upperRowColpadding = padding[row - 1] - currentTowColpadding || 0;
  const downRowColpadding = padding[row + 1] - currentTowColpadding || 0;

  const isUp = isTriangleUp({ row, col }, colsPerRow);
  return isUp
    ? [
        [0, -1], // left
        [0, 1], // right
        [1, 0 - downRowColpadding], // bottom
      ]
    : [
        [0, -1], // left
        [0, 1], // right
        [-1, 0 - upperRowColpadding], // top
      ];
};

export const calculatePosition = (
  triangle: TriangleState,
  size: number,
  padding: number[]
) => {
  const triangleHeight = (size * Math.sqrt(3)) / 2;
  const halfSize = size / 2;
  const rowPadding = padding[triangle.row] * halfSize;
  const xSize = triangle.col * halfSize + rowPadding;
  const ySize = triangle.row * triangleHeight;
  const x = xSize + halfSize;
  const y = ySize + halfSize;
  return { x, y, triangleHeight };
};

export const calculateRowColFromPosition = (
  x: number,
  y: number,
  size: number,
  padding: number[]
) => {
  const triangleHeight = (size * Math.sqrt(3)) / 2;
  const halfSize = size / 2;

  const row = Math.floor(y / triangleHeight);
  const rowPadding = padding[row] * halfSize;
  const col = Math.floor((x - halfSize - rowPadding) / halfSize);

  return { row, col };
};

export const buildNewShape = (): TriangleState[] => {
  const shapeSize = getRandomNumber(1, 6);
  const color = getRandomColor();
  const newShape: TriangleState[] = [];
  const visited = new Set<string>();

  const initialRow = 1;
  const initialCol = getRandomNumber(0, 1);

  const initialTriangle: TriangleState = {
    row: initialRow,
    col: initialCol,
    color,
    neighborhoodX: null,
    neighborhoodY: null,
    neighborhoodZ: null,
  };

  newShape.push(initialTriangle);
  visited.add(`${initialRow}-${initialCol}`);

  const maxIterations = 50;
  for (let iteration = 0; iteration < maxIterations; iteration++) {
    if (newShape.length >= shapeSize) {
      break;
    }

    let currentTriangle = newShape[newShape.length - 1];
    const neighbors = getNeighbors(currentTriangle, newShape, colsPerRowShape);
    const availableNeighbors = Object.entries(neighbors)
      .filter(([key, value]) => value === null)
      .map(([key]) => key);

    if (availableNeighbors.length > 0) {
      const randomNeighbor =
        availableNeighbors[getRandomNumber(0, availableNeighbors.length - 1)];

      const neighborOffsets = getNeighborOffsets(
        currentTriangle.row,
        currentTriangle.col,
        colsPerRowShape
      );
      const [offsetX, offsetY] =
        neighborOffsets[["X", "Y", "Z"].indexOf(randomNeighbor)];

      const newRow = currentTriangle.row + offsetX;
      const newCol = currentTriangle.col + offsetY;

      if (
        newRow >= 0 &&
        newRow < rowsOnGrid &&
        newCol >= 0 &&
        newCol < colsPerRowShape[newRow]
      ) {
        const newTriangle: TriangleState = {
          row: newRow,
          col: newCol,
          color,
          neighborhoodX: null,
          neighborhoodY: null,
          neighborhoodZ: null,
        };

        if (randomNeighbor === "X") {
          currentTriangle.neighborhoodX = newTriangle;
          newTriangle.neighborhoodX = currentTriangle;
        } else if (randomNeighbor === "Y") {
          currentTriangle.neighborhoodY = newTriangle;
          newTriangle.neighborhoodY = currentTriangle;
        } else if (randomNeighbor === "Z") {
          currentTriangle.neighborhoodZ = newTriangle;
          newTriangle.neighborhoodZ = currentTriangle;
        }

        newShape.push(newTriangle);
        visited.add(`${newRow}-${newCol}`);
      }
    } else {
      break;
    }
  }

  return newShape;
};


File: helpers/calculations.ts
import { colors } from "./constants";

export function getRandomNumber(min: number, max: number) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

export const getRandomColor = () => {
  const colorIndex = getRandomNumber(0, colors.length - 1);
  return colors[colorIndex];
};

export function getRowColFromIndex(
  index: number,
  _numRows: number,
  numCols: number
): { row: number; col: number } {
  // Calculate the row and column
  const row = Math.floor(index / numCols);
  const col = index % numCols;

  return { row, col };
}

type Matrix<T> = T[][];

export function combineMatrices<T>(matrices: Matrix<T>[]): T[][][] {
  if (matrices.length === 0) return [];

  const rows = matrices[0].length;
  const cols = matrices[0][0].length;
  const depth = matrices.length;

  // Initialize the resulting 3D matrix
  const result: T[][][] = Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => Array.from({ length: depth }))
  );

  // Populate the result matrix with values from input matrices
  for (let d = 0; d < depth; d++) {
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        result[i][j][d] = matrices[d][i][j];
      }
    }
  }

  return result;
}

export function buildUnitByDepthCustom(
  initialY: number,
  finalY: number,
  maxValue: number,
  items: number
): number[] {
  // Define coefficients based on the constraints
  const c: number = initialY; // f(0) = initialY

  // Setup the system of equations to solve for 'a' and 'b'
  // f(1) = a + b + c = finalY
  // f(0.5) = 0.25a + 0.5b + c = maxValue (peak at x=0.5)
  const equations: [number[], number[]] = [
    [0.25, 0.5], // Coefficients for x^2 and x in the equation for maxValue
    [1, 1], // Coefficients for x^2 and x in the equation for finalY
  ];
  const constants: number[] = [
    maxValue - initialY, // Constant term for the equation for maxValue
    finalY - initialY, // Constant term for the equation for finalY
  ];

  // Solve the system of linear equations
  const [a, b]: number[] = solveLinearSystem(equations, constants);

  // Generate polynomial values
  const x: number[] = Array.from({ length: items }, (_, i) => i / (items - 1));
  const unit: number[] = x
    .map((x) => a * x * x + b * x + c)
    .map((val) => Math.round(val));
  console.log("unit");
  console.log(unit);

  return unit;
}

// Helper function to solve a system of linear equations using matrix operations
function solveLinearSystem(
  equations: [number[], number[]],
  constants: number[]
): number[] {
  // Using Cramer's Rule or any matrix library that can solve linear systems
  const [[a11, a12], [a21, a22]]: [number[], number[]] = equations;
  const [b1, b2]: number[] = constants;
  const det: number = a11 * a22 - a12 * a21; // Determinant of the matrix
  const detA: number = b1 * a22 - b2 * a12; // Determinant for 'a'
  const detB: number = a11 * b2 - a21 * b1; // Determinant for 'b'

  if (det === 0) throw new Error("No unique solution");

  return [detA / det, detB / det];
}


File: helpers/types.ts
import { colors } from "./constants";
import * as tfType from "@tensorflow/tfjs";

export interface TriangleState {
  row: number;
  col: number;
  color: Colors | null;
  neighborhoodX: TriangleState | null;
  neighborhoodY: TriangleState | null;
  neighborhoodZ: TriangleState | null;
}

type Colors = (typeof colors)[number];

export type FixedLengthArray<T, L extends number> = L extends L
  ? number extends L
    ? T[]
    : _FixedLengthArray<T, L, []>
  : never;

type _FixedLengthArray<
  T,
  L extends number,
  R extends unknown[]
> = R["length"] extends L ? R : _FixedLengthArray<T, L, [T, ...R]>;

export type TensorGameState = [
  [tfType.Tensor, tfType.Tensor, tfType.Tensor, tfType.Tensor],
  [tfType.Tensor, tfType.Tensor, tfType.Tensor]
];

export type Memory = {
  state: TensorGameState;
  action: tfType.Tensor;
  reward: number;
  nextState: TensorGameState;
  done: boolean;
};


File: helpers/constants.ts
import { TriangleState } from "./types";

export const gridSize =
  typeof window === "undefined"
    ? 500
    : Math.min(window.innerWidth, window.innerHeight, 600) * 0.7;
export const colsPerRowGrid = [9, 11, 13, 15, 15, 13, 11, 9];
export const rowsOnGrid = colsPerRowGrid.length;
export const triangleSizeGrid = gridSize / (rowsOnGrid + 1);
export const maxGridCols = Math.max(...colsPerRowGrid);
export const gridPadding = colsPerRowGrid.map(
  (cols) => (maxGridCols - cols) / 2
);

export const colsPerRowGridPadded = [15, 15, 15, 15, 15, 15, 15, 15];

export const shapeSize = triangleSizeGrid * 3;
export const colsPerRowShape = [3, 3];
export const trianglesShapeSize = triangleSizeGrid;
export const maxShapeCols = Math.max(...colsPerRowShape);
export const shapePadding = colsPerRowShape.map(
  (cols) => (maxShapeCols - cols) / 2
);

export const colors = [
  "#ff006e",
  "#ffbe0b",
  "#fb5607",
  "#8338ec",
  "#3a86ff",
] as const;

export const invalidTriangle: TriangleState = {
  row: -1,
  col: -1,
  color: null,
  neighborhoodX: null,
  neighborhoodY: null,
  neighborhoodZ: null,
};

export const horizontalLines = [
  [3, 4, 5, 6, 7, 8, 9, 10, 11],
  [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27],
  [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43],
  [45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
  [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74],
  [76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88],
  [92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102],
  [108, 109, 110, 111, 112, 113, 114, 115, 116],
];

export const diagonalXLines = [
  [3, 4, 17, 18, 31, 32, 45, 46, 60],
  [5, 6, 19, 20, 33, 34, 47, 48, 51, 52, 76],
  [7, 8, 21, 22, 35, 36, 49, 50, 63, 64, 77, 78, 92],
  [9, 10, 23, 24, 37, 38, 51, 52, 56, 66, 79, 80, 93, 94, 108],
  [11, 25, 26, 39, 40, 53, 54, 67, 68, 81, 82, 95, 96, 109],
  [27, 41, 42, 55, 56, 69, 70, 83, 84, 97, 98, 111, 112],
  [43, 57, 58, 71, 72, 85, 86, 99, 100, 113, 114],
  [59, 73, 74, 87, 88, 101, 102, 115, 116],
];

export const diagonalYLines = [
  [45, 60, 61, 76, 77, 82, 93, 108, 109],
  [31, 46, 47, 62, 63, 78, 79, 94, 95, 110, 111],
  [17, 32, 33, 48, 49, 64, 65, 80, 81, 96, 97, 112, 113],
  [3, 18, 19, 34, 35, 50, 51, 66, 67, 82, 83, 98, 99, 114, 115],
  [4, 5, 20, 21, 36, 37, 52, 53, 68, 69, 84, 85, 100, 101, 116],
  [6, 7, 22, 23, 38, 39, 54, 55, 70, 71, 86, 87, 102],
  [8, 9, 24, 25, 40, 41, 56, 57, 72, 73, 88],
  [10, 11, 26, 27, 42, 43, 58, 59, 74],
];

export const allLines = [
  ...diagonalXLines,
  ...diagonalYLines,
  ...horizontalLines,
  ...diagonalXLines.map((line) => line.map((i) => i * 2)),
  ...diagonalYLines.map((line) => line.map((i) => i * 2)),
  ...horizontalLines.map((line) => line.map((i) => i * 2)),
];


File: contexts/HexGridContext.tsx
"use client";

import { createContext, useContext, useRef, ReactNode } from "react";
import Game from "../game";

interface HexGridContextProps {
  game: Game;
}

const HexGridContext = createContext<HexGridContextProps | undefined>(
  undefined
);

export const HexGridProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const gameRef = useRef<Game>(new Game());

  return (
    <HexGridContext.Provider value={{ game: gameRef.current }}>
      {children}
    </HexGridContext.Provider>
  );
};

export const useHexGrid = () => {
  const context = useContext(HexGridContext);
  if (!context) {
    throw new Error("useHexGrid must be used within a HexGridProvider");
  }
  return context;
};


File: learn/DQNAgent.ts
import * as tfType from "@tensorflow/tfjs";
import {
  explorationDecay,
  learningRate,
  updateTargetNetworkEveryNSteps,
} from "./configs";
import { Memory, TensorGameState, TriangleState } from "../helpers/types";
import {
  getIndexFromColAndRow,
  getRandomNotEmptyShapeElementIndex,
} from "../helpers/triangles";
import {
  buildUnitByDepthCustom,
  getRandomNumber,
} from "../helpers/calculations";
import { colsPerRowGridPadded, gridPadding } from "../helpers/constants";

export class DQNAgent {
  public actionTimes: number[] = [];
  public replayTimes: number[] = [];
  private actionSize: number;
  public memory: Memory[];
  private replayBufferSize: number;

  private discountFactor: number;
  public explorationRate: number;
  private explorationMin: number;
  private explorationDecay: number;
  private learningRate: number;
  private model: tfType.LayersModel;
  private targetModel: tfType.LayersModel;
  private updateTargetNetworkFrequency: number;
  private trainStep: number;
  private totalLoss: number;
  private batchCount: number;
  private tf: typeof tfType;
  private modelName: string;
  public averageLoss: number;
  private unistByDepth: (index: number) => number;
  private layersDepth: number;
  private layersUnitsByDepths: number[];
  private inputSize: number;
  private dropoutRate: number;
  constructor(actionSize: number, tf: typeof tfType) {
    this.modelName = "indexeddb://DQNAgentModel";
    this.layersDepth = 36;
    this.actionSize = actionSize;
    this.dropoutRate = 0.01;
    this.inputSize = 4 * 8 * 15 + 3 * 2 * 3;
    this.layersUnitsByDepths = buildUnitByDepthCustom(
      Math.floor((this.inputSize * 3) / 2),
      this.actionSize * 2,
      this.inputSize * 3,
      this.layersDepth
    );
    this.unistByDepth = (index) => this.layersUnitsByDepths[index];
    this.tf = tf;
    this.actionSize = actionSize;
    this.memory = [];
    this.discountFactor = 0.95;
    this.explorationRate = 1.0;
    this.explorationMin = 0.02;
    this.replayBufferSize = 200_000_000;
    this.explorationDecay = explorationDecay;
    this.learningRate = learningRate;
    this.model = this.buildModel(this.layersDepth, this.unistByDepth);
    this.targetModel = this.buildModel(this.layersDepth, this.unistByDepth);
    this.updateTargetNetworkFrequency = updateTargetNetworkEveryNSteps;
    this.trainStep = 0;
    this.totalLoss = 0;
    this.batchCount = 0;
    this.averageLoss = 0;

    this.loadModelWeights().catch((err) => {
      console.log("No saved model found, starting with a new model.");
    });
  }

  buildModel(layerDepth: number, unitsFunction: (index: number) => number) {
    const gridInputs = [];
    for (let i = 0; i < 4; i++) {
      gridInputs.push(this.tf.input({ shape: [8, 15, 3] }));
    }

    const shapeInputs = [];
    for (let i = 0; i < 3; i++) {
      shapeInputs.push(this.tf.input({ shape: [2, 3, 3] }));
    }

    const flatGridInputs = gridInputs.map(
      (input) => this.tf.layers.flatten().apply(input) as tfType.SymbolicTensor
    );

    const flatShapeInputs = shapeInputs.map(
      (input) => this.tf.layers.flatten().apply(input) as tfType.SymbolicTensor
    );

    const concat = this.tf.layers
      .concatenate()
      .apply([...flatGridInputs, ...flatShapeInputs]) as tfType.SymbolicTensor;

    let x: tfType.SymbolicTensor = concat;

    // Dynamically create dense layers based on layerDepth
    for (let i = 0; i < layerDepth; i++) {
      const units = unitsFunction(i);
      x = this.tf.layers
        .dense({
          units: units,
          activation: "relu",
        })
        .apply(x) as tfType.SymbolicTensor;

      // x = this.tf.layers.batchNormalization().apply(x) as tfType.SymbolicTensor;
      x = this.tf.layers
        .dropout({ rate: this.dropoutRate })
        .apply(x) as tfType.SymbolicTensor;
    }

    // Output layer
    const output = this.tf.layers
      .dense({ units: this.actionSize, activation: "linear" })
      .apply(x) as tfType.SymbolicTensor;

    const model = this.tf.model({
      inputs: [...gridInputs, ...shapeInputs],
      outputs: output,
    });
    model.summary();

    model.compile({
      loss: "meanSquaredError",
      optimizer: this.tf.train.adam(this.learningRate),
    });

    return model;
  }

  remember(
    state: TensorGameState,
    action: tfType.Tensor,
    reward: number,
    nextState: TensorGameState,
    done: boolean
  ) {
    this.memory = this.memory.filter((memory, index) => memory.reward != 0);
    if (this.memory.length >= this.replayBufferSize) this.memory.shift();
    this.memory.push({ state, action, reward, nextState, done });
  }

  act(
    state: TensorGameState,
    triangles: TriangleState[],
    shapes: TriangleState[][],
    optionsByShape: { row: number; col: number }[][]
  ): tfType.Tensor {
    const start = Date.now(); // Start timing
    const [gridInputs, shapeInputs] = state;

    const reshapedGridInputs = gridInputs.map((input) =>
      input.reshape([1, 8, 15, 3])
    );

    const reshapedShapeInputs = shapeInputs.map((input) =>
      input.reshape([1, 2, 3, 3])
    );

    let action;
    if (Math.random() <= this.explorationRate) {
      // Exploration: Randomly select a shape and a valid position
      const shapeIndex = getRandomNotEmptyShapeElementIndex(optionsByShape);
      const shapeAvailablePositions = optionsByShape[shapeIndex];
      const randomPositionIndex = getRandomNumber(
        0,
        shapeAvailablePositions.length - 1
      );
      const randomAvailablePosition =
        shapeAvailablePositions[randomPositionIndex];

      const { col: unPaddedCol, row } = randomAvailablePosition;
      const rowPadding = gridPadding[row];
      const col = unPaddedCol + rowPadding;
      const positionIndex = getIndexFromColAndRow(
        col,
        row,
        colsPerRowGridPadded
      );

      action = this.tf.tensor([shapeIndex, positionIndex], [1, 2]);
    } else {
      // Exploitation: Predict the best shape and position
      const predictedQualityValues = this.model.predict([
        ...reshapedGridInputs,
        ...reshapedShapeInputs,
      ]) as tfType.Tensor;

      // Extract shape and position predictions
      const shapeProbabilities = predictedQualityValues.slice([0, 0], [1, 3]);
      const shapeIndex = shapeProbabilities.argMax(1).dataSync()[0]; // Select the shape with the highest predicted quality

      const positionProbabilities = predictedQualityValues.slice(
        [0, 3],
        [1, 120]
      );
      const positionIndex = positionProbabilities.argMax(1).dataSync()[0]; // Select the position with the highest predicted quality

      action = this.tf.tensor([shapeIndex, positionIndex], [1, 2]);
    }

    const end = Date.now(); // End timing
    this.actionTimes.push(end - start); // Store action time
    return action;
  }

  async replay(batchSize: number) {
    const start = Date.now();
    const rewardFulMemories = this.memory.filter(
      (memory, index) => memory.reward != 0
    );
    const maxIndex = rewardFulMemories.length - 1 - batchSize;
    const randomIndex = Math.floor(Math.random() * maxIndex);
    const minibatch = rewardFulMemories.slice(
      randomIndex,
      randomIndex + batchSize
    );
    let batchLoss = 0;

    for (const { state, action, reward, nextState, done } of minibatch) {
      // Reshape the state and nextState tensors to include batch and channels dimensions
      const [nextState1, nextState2] = nextState;
      const [state1, state2] = state;

      const reshapedNextStateGrid = nextState1.map((input) =>
        input.reshape([1, 8, 15, 3])
      );
      const reshapedNextStateShape = nextState2.map((input) =>
        input.reshape([1, 2, 3, 3])
      );

      const reshapedStateGrid = state1.map((input) =>
        input.reshape([1, 8, 15, 3])
      );
      const reshapedStateShape = state2.map((input) =>
        input.reshape([1, 2, 3, 3])
      );

      const targetQ =
        reward +
        this.discountFactor *
          (done
            ? 0
            : Math.max(
                ...Array.from(
                  (
                    this.targetModel.predict([
                      ...reshapedNextStateGrid,
                      ...reshapedNextStateShape,
                    ]) as tfType.Tensor<tfType.Rank.R2>
                  ).dataSync()
                )
              ));
      const qValues = this.model.predict([
        ...reshapedStateGrid,
        ...reshapedStateShape,
      ]) as tfType.Tensor<tfType.Rank.R2>;

      const qValuesCopy = qValues.arraySync() as number[][];

      const [shapeIndex, targetIndex] = Array.from(
        action.dataSync() as unknown as number[]
      );

      const actionIndex = 3 + targetIndex;
      qValuesCopy[0][actionIndex] = targetQ;

      const targetTensor = this.tf.tensor(qValuesCopy);

      await this.model.fit(
        [...reshapedStateGrid, ...reshapedStateShape],
        targetTensor,
        {
          epochs: 1,
          verbose: 0,
          batchSize: batchSize,
          callbacks: {
            onBatchEnd: async (batch, logs) => {
              batchLoss += logs?.loss || 0;
              this.trainStep++;
              if (this.trainStep % this.updateTargetNetworkFrequency === 0) {
                this.updateTargetNetwork();
                this.saveModelWeights();
              }
            },
          },
        }
      );

      this.tf.dispose([qValues, targetTensor, targetTensor]);
    }

    this.totalLoss += batchLoss;
    this.batchCount++;
    const currentAverageLoss = this.totalLoss / this.batchCount;

    this.averageLoss = currentAverageLoss;
    if (this.explorationRate > this.explorationMin) {
      this.explorationRate *= this.explorationDecay;
    }
    const end = Date.now();

    const duration = end - start;
    this.replayTimes.push(duration);
  }

  async saveModelWeights() {
    await this.model.save(this.modelName);
    console.log(`Model saved to ${this.modelName}`);
  }

  async loadModelWeights() {
    try {
      const loadedModel = await this.tf.loadLayersModel(this.modelName);
      this.model.setWeights(loadedModel.getWeights());
      console.log(`Model weights loaded from ${this.modelName}`);
    } catch (error) {
      console.error("Failed to load model weights:", error);
      throw error;
    }
  }

  updateTargetNetwork() {
    this.targetModel.setWeights(this.model.getWeights());
  }
}


File: learn/GameEnvironment.ts
import * as tfType from "@tensorflow/tfjs";
import Game from "../game";
import { gridPadding } from "../helpers/constants";

export class GameEnvironment {
  private game: Game;
  private previousScore = 0;
  private howLongStaticScore = 0;

  constructor(game: Game) {
    this.game = game;
  }

  reset() {
    this.previousScore = 0;
    this.game.resetGame();
    return this.getTensorInputState();
  }

  getScore() {
    return this.game.score;
  }

  getTriangles() {
    return this.game.triangles;
  }

  getShapes() {
    return this.game.shapes;
  }

  getTensorInputState() {
    return this.game.getTensorGameState();
  }

  getValidPositions() {
    return this.game.getValidPositionsByShapes();
  }
  step(action: tfType.Tensor) {
    const [actionList] = action.toInt().arraySync() as number[][];
    const [shapeIndex, paddedIndexTarget] = actionList;

    const unPaddingRowCol = (paddedIndex: number) => {
      const row = Math.floor(paddedIndex / 15);
      const padding = gridPadding[row];
      const col = (paddedIndex % 15) - padding;
      return [col, row];
    };

    const [col, row] = unPaddingRowCol(paddedIndexTarget);

    this.game.moveShapeToTriangle(col ?? 0, row ?? 0, shapeIndex);
    const nextState = this.getTensorInputState();

    const score = this.getScore();
    const pointsDiff = score - this.previousScore;
    if (pointsDiff !== 0) {
      this.howLongStaticScore = 0;
    } else {
      this.howLongStaticScore += 1;
    }
    const shapeSelectedLength = this.game.shapes[shapeIndex].length;
    const done = this.game.isGameOver();
    const reward = done
      ? -2
      : pointsDiff > 0
      ? (pointsDiff - (shapeSelectedLength - 2)) / 6
      : Math.max(-0.1 * this.howLongStaticScore, -1);

    if (done) {
      console.log(
        "%c GAME OVER! ",
        "background: #222; color: #f00;  font-weight: bold; font-size: 16px;"
      );
    }

    this.previousScore = score;
    return { nextState, reward, done };
  }
}


File: learn/configs.ts
export const movementsBatchSize = 1;
export const trainingEpisodes = 10000;
export const intervalToForceUpdate = 200;
export const learningRate = 0.0002;

export const replayEveryNSteps = 200;
export const updateTargetNetworkEveryNSteps = 100;
export const explorationDecay = 0.9995;


