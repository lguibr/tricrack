File: page.tsx
"use client";
import { HexGridProvider } from "./contexts/HexGridContext";
import dynamic from "next/dynamic";
const HexGrid = dynamic(() => import("@/app/components/HexGrid"), {
  ssr: false,
});
export default function Home() {
  return (
    <main>
      <HexGridProvider>
        <HexGrid />
      </HexGridProvider>
    </main>
  );
}


File: manifest.ts
import { MetadataRoute } from "next";

export default function manifest(): MetadataRoute.Manifest {
  return {
    name: "TriCrack",
    short_name: "TriCrack",
    orientation: "any",
    scope: "/",
    start_url: "/",
    display: "standalone",
    theme_color: "#111",
    background_color: "#222",
    icons: [
      {
        src: "/android-chrome-192x192.png",
        sizes: "192x192",
        type: "image/png",
        purpose: "maskable",
      },
      {
        src: "/android-chrome-512x512.png",
        sizes: "512x512",
        type: "image/png",
      },
    ],
  };
}


File: _app.tsx
import type { AppProps } from "next/app";

export default function MyApp({ Component, pageProps }: AppProps) {
  return (
    <>
      <meta
        name="viewport"
        content="minimum-scale=1, initial-scale=1, width=device-width, shrink-to-fit=no, user-scalable=no, viewport-fit=cover"
      />
      <meta name="application-name" content="tricrack 0.1" />
      <meta name="apple-mobile-web-app-capable" content="yes" />
      <meta name="apple-mobile-web-app-status-bar-style" content="default" />
      <meta name="apple-mobile-web-app-title" content="tricrack 0.1" />
      <meta name="description" content="Best tricrack 0.1 in the world" />
      <meta name="format-detection" content="telephone=no" />
      <meta name="mobile-web-app-capable" content="yes" />
      <meta name="msapplication-config" content="/browserconfig.xml" />
      <meta name="msapplication-TileColor" content="#2B5797" />
      <meta name="msapplication-tap-highlight" content="no" />
      <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
      <link
        rel="apple-touch-icon"
        sizes="152x152"
        href="/apple-touch-icon.png"
      />
      <link
        rel="apple-touch-icon"
        sizes="180x180"
        href="/apple-touch-icon.png"
      />
      <link
        rel="apple-touch-icon"
        sizes="167x167"
        href="/apple-touch-icon.png"
      />
      <link
        rel="icon"
        type="image/png"
        sizes="32x32"
        href="/favicon-32x32.png"
      />
      <link
        rel="icon"
        type="image/png"
        sizes="16x16"
        href="/favicon-16x16.png"
      />
      <link rel="manifest" href="/manifest.json" />
      <link rel="shortcut icon" href="/favicon.ico" />
      <meta name="theme-color" content="#000" />
      <meta name="twitter:card" content="summary" />
      <meta name="twitter:url" content="https://tricrack.luisguilher.me" />
      <meta name="title" content="Tricrack" />
      <meta name="twitter:title" content="Tricrack" />
      <meta name="twitter:description" content="Tricrack" />
      <meta
        name="twitter:image"
        content="https://tricrack.luisguilher.me/android-chrome-192x192.png"
      />
      <meta name="twitter:creator" content="@luisguilher_me" />
      <meta property="og:type" content="website" />
      <meta property="og:title" content="tricrack 0.1" />
      <meta property="og:description" content="Tricrack" />
      <meta property="og:site_name" content="Tricrack" />
      <meta property="og:url" content="https://tricrack.luisguilher.me" />
      <meta
        property="og:image"
        content="https://tricrack.luisguilher.me/apple-touch-icon.png"
      />
      <Component {...pageProps} />;
    </>
  );
}


File: layout.tsx
"use client";

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import StyledComponentsRegistry from "@/lib/registry";
import { Analytics } from "@vercel/analytics/react";
import { useEffect } from "react";

const inter = Inter({ subsets: ["latin"] });

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  let sw: ServiceWorkerContainer | undefined;

  if (typeof window !== "undefined") {
    sw = window?.navigator?.serviceWorker;
  }
  useEffect(() => {
    if (sw) {
      sw.register("/sw.js", { scope: "/" })
        .then((registration) => {
          console.log(
            "Service Worker registration successful with scope: ",
            registration.scope
          );
        })
        .catch((err) => {
          console.log("Service Worker registration failed: ", err);
        });
    }
  }, [sw]);

  return (
    <StyledComponentsRegistry>
      <html lang="en">
        <script src="DragDropTouch.js" async></script>
        <body className={inter.className}>
          <Analytics />
          {children}
        </body>
      </html>
    </StyledComponentsRegistry>
  );
}


File: components/HexGrid.tsx
import "@tensorflow/tfjs-backend-webgpu";
import * as tfjsWasm from "@tensorflow/tfjs-backend-wasm";

import React, { useEffect, useState } from "react";
import HexGridRender from "./HexGridRender";
import { useHexGrid } from "../contexts/HexGridContext";
import GameTrainer from "./GameTrainer";
import { intervalToForceUpdate } from "../learn/configs";

import * as tf from "@tensorflow/tfjs";
import { styled } from "styled-components";

const HexGrid: React.FC = () => {
  const { game } = useHexGrid();
  const [forceUpdate, setForceUpdate] = useState(0);
  const tfRef = React.useRef<typeof tf | null>(null);
  const [training, setTraining] = useState(false);

  const clearStorage = async () => {
    // Clear localStorage
    localStorage.clear();
    // Clear indexedDB
    const databases = await indexedDB.databases();
    databases.forEach((db) => {
      indexedDB.deleteDatabase(db.name!);
    });
    console.log("Cleared indexDB and localStorage");
  };

  useEffect(() => {
    const debounced = setTimeout(() => {
      const loadTf = async () => {
        if (tfRef.current) return;
        console.group("Loading TensorFlow");

        await tfjsWasm.setWasmPaths(
          `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${tfjsWasm.version_wasm}/dist/`
        );

        await tf.setBackend("webgpu");

        await tf.ready();
        const currentBackend = await tf.getBackend();
        console.log(`TensorFlow is ready with backend: ${currentBackend}`);
        console.groupEnd();
        tfRef.current = tf;
      };

      if (tfRef.current == null) loadTf();
    }, 1);
    const interval = setInterval(() => {
      setForceUpdate((prev) => prev + 1);
    }, intervalToForceUpdate);

    return () => {
      clearInterval(interval);
      clearTimeout(debounced);
    };
  }, []);

  if (!game || tfRef.current == null) return null;

  return (
    <div style={{ position: "relative" }}>
      <HexGridRender frame={forceUpdate} game={game} />
      <Button onClick={() => setTraining((p) => !p)}>
        {training ? "Stop Training" : "Start Training"}
      </Button>
      <ClearButton onClick={clearStorage}>Clear Storage</ClearButton>

      {training && <GameTrainer tf={tfRef.current} game={game} />}
    </div>
  );
};

export default HexGrid;

const Button = styled.button`
  position: absolute;
  top: 10px;
  right: 10px;
  padding: 10px;
  border-radius: 5px;
  background-color: #ff006e;
  color: white;
  font-size: 16px;
  border: none;
  cursor: pointer;
  transition: background-color 0.3s;
  &:hover {
    background-color: #ff0055;
  }
`;

const ClearButton = styled.button`
  position: absolute;
  bottom: 50px;
  right: 10px;
  padding: 10px;
  border-radius: 5px;
  background-color: #ff006e;
  color: white;
  font-size: 16px;
  border: none;
  cursor: pointer;
  transition: background-color 0.3s;
  &:hover {
    background-color: #ff0055;
  }
`;


File: components/Triangle.tsx
import { styled } from "styled-components";

export const Triangle = styled.div<{
  $x: number;
  $y: number;
  $size: number;
  $triangleHeight: number;
  $isUp: boolean;
  $color?: string | null;
  $isHovering?: string | null;
  $zIndex: number;
  $rowIndex: number;
}>`
  position: absolute;
  width: 0;
  height: 0;
  left: ${({ $x }) => $x}px;
  top: ${({ $y, $rowIndex }) => $y + $rowIndex * 4}px;
  z-index: ${({ $zIndex }) => $zIndex};
  pointer-events: auto;
  border-radius: 5%;
  border-left: ${({ $size }) => $size / 2 - 3}px solid transparent;
  border-right: ${({ $size }) => $size / 2 - 3}px solid transparent;
  ${({ $isUp, $triangleHeight, $color, $isHovering }) =>
    $isUp
      ? `
    border-bottom: ${$triangleHeight}px solid ${
          $isHovering ? $isHovering : $color || "gray"
        };
  `
      : `
    border-top: ${$triangleHeight}px solid ${
          $isHovering ? $isHovering : $color || "gray"
        };
  `}
`;


File: components/HexGridRender.tsx
// src/app/components/HexGridRender.tsx
"use client";
import React, {
  MouseEventHandler,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import {
  calculatePosition,
  calculateRowColFromPosition,
  isTriangleUp,
} from "../helpers/triangles";
import {
  colsPerRowGrid,
  triangleSizeGrid,
  gridSize,
  gridPadding,
  colors,
  trianglesShapeSize,
} from "../helpers/constants";
import { TriangleState } from "../helpers/types";
import styled from "styled-components";
import { Triangle } from "./Triangle";
import ShapeRenderer from "./ShapeRenderer";
import Modal from "./Modal";
import Image from "next/image";
import Game from "../game";

const offSetY = 0;

const HexGridRender: React.FC<{ game: Game; frame: number }> = ({
  game,
}) => {
  const [draggedShape, setDraggedShape] = useState<{
    shape: TriangleState[] | null;
    index: number | null;
  }>({ shape: null, index: null });
  const gridRef = useRef<HTMLDivElement>(null);
  const gridPosition = gridRef.current?.getBoundingClientRect();

  const motionOffset = triangleSizeGrid / 5;

  const offsets = useMemo(
    () => [
      [0, 0],
      [0, -motionOffset],
      [0, motionOffset],
      [-motionOffset, 0],
      [motionOffset, 0],
      [-motionOffset, -motionOffset],
      [-motionOffset, motionOffset],
      [motionOffset, -motionOffset],
      [motionOffset, motionOffset],
      [2 * motionOffset, 0],
      [-2 * motionOffset, 0],
      [0, 2 * motionOffset],
      [0, -2 * motionOffset],
      [motionOffset, 2 * motionOffset],
      [motionOffset, -2 * motionOffset],
      [-motionOffset, 2 * motionOffset],
      [-motionOffset, -2 * motionOffset],
      [2 * motionOffset, motionOffset],
      [2 * motionOffset, -motionOffset],
      [-2 * motionOffset, motionOffset],
      [-2 * motionOffset, -motionOffset],
      [2 * motionOffset, 2 * motionOffset],
      [2 * motionOffset, -2 * motionOffset],
      [-2 * -motionOffset, 2 * motionOffset],
      [-2 * -motionOffset, -2 * motionOffset],
    ],
    [motionOffset]
  );
  const [gameOver, setGameOver] = useState(false);
  const [hoveredTriangles, setHoveredTriangles] = useState<Set<string>>(
    new Set()
  );

  const [touchHandled, setTouchHandled] = useState(false);

  const handleTouchStart = () => {
    setTouchHandled(true);
  };

  const handleClick =
    (callback: (e: MouseEvent) => void) => (e: MouseEvent) => {
      if (touchHandled) {
        setTouchHandled(false);
        return;
      }
      callback(e);
    };

  useEffect(() => {
    const isGameOver = game.isGameOver();
    if (isGameOver) {
      setGameOver(true);
    }
  }, [game]);

  const handleDragStart = useCallback(
    (index: number, _: React.DragEvent, shape: TriangleState[]) => {
      setDraggedShape({ shape, index });
    },
    []
  );

  const handleDragOver = useCallback(
    (event: React.DragEvent) => {
      offsets.forEach(([ox, oy]) => {
        const x = event.clientX - (gridPosition?.left || 0) + ox;
        const y = event.clientY - (gridPosition?.top || 0) - offSetY + oy;

        const { col, row } = calculateRowColFromPosition(
          x,
          y,
          triangleSizeGrid,
          gridPadding
        );

        const targetTriangle = game.triangles.find(
          (t) => t.row === row && t.col === col
        );

        if (targetTriangle) {
          const { newHoveredTriangles, isValid } =
            game.calculateHoveredAndValidPositions(
              event,
              targetTriangle,
              false,
              draggedShape.shape
            ) ?? {};

          if (isValid && newHoveredTriangles) {
            setHoveredTriangles(newHoveredTriangles);
            return;
          }
        }
      });
    },
    [draggedShape.shape, game, gridPosition?.left, gridPosition?.top, offsets]
  );

  const handleDrop = useCallback(
    (event: React.DragEvent) => {
      let placed = false;
      offsets.forEach(([ox, oy]) => {
        if (placed) return;
        const x = event.clientX - (gridPosition?.left || 0) + ox;
        const y = event.clientY - (gridPosition?.top || 0) - offSetY + oy;

        const { col, row } = calculateRowColFromPosition(
          x,
          y,
          triangleSizeGrid,
          gridPadding
        );

        const targetTriangle = game.triangles.find(
          (t) => t.row === row && t.col === col
        );

        if (targetTriangle) {
          const { validPositions, isValid } =
            game.calculateHoveredAndValidPositions(
              event,
              targetTriangle,
              true,
              draggedShape.shape
            ) ?? {};
          if (
            isValid &&
            draggedShape.index !== null &&
            draggedShape.shape != null &&
            draggedShape.shape.length > 0
          ) {
            const color = draggedShape.shape[0].color;
            placed = true;
            game.addToScore(draggedShape.shape.length);
            game.setTriangles((prevTriangles) =>
              prevTriangles.map((triangle) =>
                validPositions?.some(
                  (pos) => pos.row === triangle.row && pos.col === triangle.col
                )
                  ? {
                      ...triangle,
                      color,
                    }
                  : triangle
              )
            );
            game.setShape(draggedShape.index, []);
          }
        }
        setDraggedShape({ shape: null, index: null });
        setHoveredTriangles(new Set());
      });
    },
    [
      offsets,
      gridPosition?.left,
      gridPosition?.top,
      game,
      draggedShape.index,
      draggedShape.shape,
    ]
  );

  const handleDragLeave = useCallback(() => {
    setHoveredTriangles(new Set());
  }, []);

  const reset = useCallback(() => {
    setGameOver(false);
    game.resetGame();
  }, [game]);

  const undoLastMove = useCallback(() => {
    setGameOver(false);
    game.undo();
  }, [game]);

  return (
    <Container
      onDrop={(event) => handleDrop(event)}
      onDragOver={(event) => handleDragOver(event)}
      onMouseUp={() => {
        setDraggedShape({ shape: null, index: null });
        setHoveredTriangles(new Set());
      }}
      onDragLeave={handleDragLeave}
    >
      <Modal open={gameOver} setOpen={setGameOver}>
        <ModalContent>
          <Image
            src="/favicon.png"
            alt="Logo Tricrack"
            width={150}
            height={150}
          />
          <h1>Game Over</h1>
          <ModalButtons>
            <Image
              src="/restart.png"
              alt="restart game"
              width={50}
              height={50}
              onClick={
                handleClick((e) => {
                  e.preventDefault();
                  reset();
                }) as unknown as MouseEventHandler
              }
              onTouchStart={handleTouchStart}
              style={{ cursor: "pointer" }}
            />

            <Image
              src="/undo.png"
              alt="undo movement"
              width={50}
              height={50}
              style={{ cursor: "pointer" }}
              onClick={
                handleClick((e) => {
                  e.preventDefault();
                  undoLastMove();
                }) as unknown as MouseEventHandler
              }
              onTouchStart={handleTouchStart}
            />
          </ModalButtons>
        </ModalContent>
      </Modal>
      <Content>
        <Header>
          <Image
            src="/restart.png"
            alt="restart game"
            width={50}
            height={50}
            onClick={
              handleClick((e) => {
                e.preventDefault();
                reset();
              }) as unknown as MouseEventHandler
            }
            onTouchStart={handleTouchStart}
            style={{ cursor: "pointer" }}
          />
          <Image
            src="/favicon.png"
            alt="Logo Tricrack"
            width={100}
            height={100}
          />
          <Image
            src="/undo.png"
            alt="undo movement"
            width={50}
            height={50}
            style={{ cursor: "pointer" }}
            onClick={
              handleClick((e) => {
                e.preventDefault();
                undoLastMove();
              }) as unknown as MouseEventHandler
            }
            onTouchStart={handleTouchStart}
          />
        </Header>

        <Score>
          <h2>▶️</h2>
          <CurrentScore>{game.score}</CurrentScore>
          <h2>⭐</h2>
          <BestScore>{game.currentHighScore}</BestScore>
        </Score>
      </Content>
      <GridContainer ref={gridRef}>
        {game.triangles.map((triangle, index) => {
          const { x, y, triangleHeight } = calculatePosition(
            triangle,
            triangleSizeGrid,
            gridPadding
          );
          const isUp = isTriangleUp(triangle, colsPerRowGrid);
          const zIndex = colsPerRowGrid[triangle.row] - triangle.col;
          const isHovered = hoveredTriangles.has(
            `${triangle.row}-${triangle.col}`
          );

          return (
            <>
              <Triangle
                key={`grid-triangle-${triangle.row}-${
                  triangle.col
                }-grid-${Date.now()}`}
                $x={x}
                $y={y}
                $size={triangleSizeGrid}
                $triangleHeight={triangleHeight}
                $isUp={isUp}
                $color={triangle.color || null}
                $zIndex={zIndex}
                $rowIndex={triangle.row}
                $isHovering={isHovered ? draggedShape.shape?.[0].color : null}
              ></Triangle>
              <div
                style={{
                  zIndex: 9999999999,
                  color: "white",
                  position: "absolute",
                  top: `${
                    y + ((trianglesShapeSize / 2) * (triangle.row + 1)) / 4
                  }px`,
                  left: `${x + trianglesShapeSize / 4}px`,
                }}
              >
                {index}
              </div>
            </>
          );
        })}
      </GridContainer>
      <OptionsContainer>
        {game.shapes?.map((shape, index) => (
          <Option
            key={index}
            onClick={() => {
              console.log(
                JSON.stringify({
                  shape: shape.map(({ col, color, row }) => ({
                    col,
                    row,
                    color,
                  })),
                })
              );
            }}
          >
            <ShapeRenderer
              shape={shape}
              onDragStart={(event) => handleDragStart(index, event, shape)}
            />
          </Option>
        ))}
      </OptionsContainer>
    </Container>
  );
};

export default HexGridRender;

const Container = styled.div`
  display: grid;
  position: relative;
  width: 100vw;
  max-width: 100vw;
  height: 100dvh;
  max-height: 100dvh;
  box-sizing: border-box;
  justify-content: center;
  align-items: center;
  justify-items: center;
`;

const GridContainer = styled.div`
  position: relative;
  height: ${gridSize}px;
  width: ${gridSize}px;
`;

const OptionsContainer = styled.div`
  position: relative;
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  justify-content: space-around;
  align-items: center;
`;

const Header = styled.div`
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
`;

const Option = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  height: 100%;
  cursor: pointer;
`;

const Content = styled.div`
  display: flex;
  width: 100%;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`;

const ModalContent = styled(Content)`
  border-radius: 8px;
  border: 1px solid #222;
  gap: 1rem;
  padding: 1rem;
  padding-top: 0rem;
`;

const Button = styled.button`
  padding: 0.5rem 1rem;
  border-radius: 4px;
  background-color: #222;
  color: #fff;
  border: none;
  cursor: pointer;
`;

const Score = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  padding: 0.5rem;
  align-items: center;
  justify-content: center;
  text-align: center;
  width: 100%;
`;

const CurrentScore = styled.h1`
  color: ${colors[colors.length - 1]};
`;
const BestScore = styled.h1`
  color: ${colors[0]};
`;

const ModalButtons = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
`;


File: components/Modal.tsx
import React from "react";
import styled from "styled-components";

// Styled components
const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: rgba(0, 0, 0, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const ModalContent = styled.div`
  position: relative;
  padding: 20px;
  background: black;
  border-radius: 8px;
  max-width: 500px;
  z-index: 1001;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
`;

interface ModalProps {
  children: React.ReactNode;
  open: boolean;
  setOpen: (open: boolean) => void;
}

const Modal: React.FC<ModalProps> = ({ children, open, setOpen }) => {
  if (!open) return null;

  return (
    <ModalOverlay onClick={() => setOpen(false)}>
      <ModalContent onClick={(e) => e.stopPropagation()}>
        {children}
      </ModalContent>
    </ModalOverlay>
  );
};

export default Modal;


File: components/ShapeRenderer.tsx
"use client";
import React from "react";
import { TriangleState } from "../helpers/types";
import { calculatePosition } from "../helpers/triangles";
import { isTriangleUp } from "../helpers/triangles";
import styled from "styled-components";
import { Triangle } from "./Triangle";
import {
  colsPerRowShape,
  shapePadding,
  shapeSize,
  trianglesShapeSize,
} from "../helpers/constants";

const ShapeContainer = styled.div`
  display: flex;
  position: relative;
  flex-direction: column;
  width: ${shapeSize}px;
  height: ${shapeSize}px;
  justify-content: center;
  align-items: center;
`;

// TODO translate the shape being dragged so it follows the cursor in perspective to the
// first triangle created used to set the shape

interface ShapeRendererProps {
  shape: TriangleState[];
  onDragStart: (event: React.DragEvent, shape: TriangleState[]) => void;
}

const ShapeRenderer: React.FC<ShapeRendererProps> = ({
  shape,
  onDragStart,
}) => {
  return (
    <ShapeContainer
      draggable
      onDragStart={(event) => onDragStart(event, shape)}
    >
      {shape.map((triangle, index) => {
        const { x, y, triangleHeight } = calculatePosition(
          triangle,
          trianglesShapeSize,
          shapePadding
        );
        const isUp = isTriangleUp(triangle, colsPerRowShape);
        const zIndex = colsPerRowShape[triangle.row] - triangle.col;

        return (
          <>
            <Triangle
              key={`shape-triangle-${triangle.row}-${
                triangle.col
              }-${index}-shape-${Date.now()}`}
              $x={x}
              $y={y}
              $size={trianglesShapeSize}
              $triangleHeight={triangleHeight}
              $isUp={isUp}
              $color={triangle.color}
              $zIndex={zIndex}
              $rowIndex={triangle.row}
              $isHovering={triangle.color || null}
              onClick={() => {}}
            ></Triangle>
            <div
              style={{
                zIndex: 9999999999,
                color: "white",
                position: "absolute",
                top: `${y + trianglesShapeSize / 4}px`,
                left: `${x + trianglesShapeSize / 4}px`,
              }}
            >
              {index}
            </div>
          </>
        );
      })}
    </ShapeContainer>
  );
};

export default ShapeRenderer;


File: components/GameTrainer.tsx
// File: GameTrainer.tsx

import React, { useEffect, useRef } from "react";
import { GameEnvironment } from "../learn/GameEnvironment";
import { DQNAgent } from "../learn/DQNAgent";
import Game from "../game";
import {
  movementsBatchSize,
  replayEveryNSteps,
  trainingEpisodes,
  actionSize,
} from "../learn/configs";
import * as tf from "@tensorflow/tfjs";
import * as tfvis from "@tensorflow/tfjs-vis";
import { styled } from "styled-components";

const GameTrainer: React.FC<{ game: Game }> = ({ game }) => {
  const [iteration, setIteration] = React.useState(0);
  const agentRef = useRef<DQNAgent | null>(null);
  const gameEnvironmentRef = useRef<GameEnvironment | null>(null);
  const haveInstantiated = useRef(false);

  const lossValues = useRef<{ x: number; y: number }[]>([]);
  const explorationRateValues = useRef<{ x: number; y: number }[]>([]);
  const scoreValues = useRef<{ x: number; y: number }[]>([]);
  const totalRewardValues = useRef<{ x: number; y: number }[]>([]);
  const actionTimeValues = useRef<{ x: number; y: number }[]>([]);
  const replayTimeValues = useRef<{ x: number; y: number }[]>([]);

  useEffect(() => {
    // Ensure GameEnvironment is created only once
    if (!gameEnvironmentRef.current) {
      gameEnvironmentRef.current = new GameEnvironment(game);
    }

    // Create and configure DQNAgent only once
    if (!agentRef.current) {
      agentRef.current = new DQNAgent(actionSize);
    }

    const trainAgent = async () => {
      if (haveInstantiated.current) return;
      haveInstantiated.current = true;
      const dqnAgent = agentRef.current!;
      const gameEnvironment = gameEnvironmentRef.current!;
      if (dqnAgent && gameEnvironment) {
        for (let iteration = 0; iteration < trainingEpisodes; iteration++) {
          setIteration(iteration + 1);
          let state = gameEnvironment.reset();
          let done = false;
          let totalReward = 0;

          while (!done) {
            const validActionsMask = gameEnvironment.getValidActionsMask();
            const action = dqnAgent.act(state, validActionsMask);
            const {
              nextState,
              reward,
              done: isDone,
            } = gameEnvironment.step(action);
            done = isDone;
            totalReward += reward;

            dqnAgent.remember(state, action, reward, nextState, isDone);
            state = nextState;

            if (dqnAgent.memory.length % replayEveryNSteps === 0) {
              await dqnAgent.replay();
              await tf.nextFrame(); // Yield control to the browser
            }

            // Dispose tensors to prevent memory leaks
            validActionsMask.dispose();
          }

          await dqnAgent.replay();
          await tf.nextFrame(); // Yield control to the browser

          // Update charts BEFORE resetting the game
          const currentAverageLoss = dqnAgent.averageLoss || 0;
          const currentExplorationRate = dqnAgent.explorationRate || 0;
          const currentScore = game.score || 0; // Capture the score before reset
          const currentActionTime = dqnAgent.actionTimes.slice(-1)[0] || 0;
          const currentReplayTime = dqnAgent.replayTimes.slice(-1)[0] || 0;

          // Push metrics to chart data
          lossValues.current.push({ x: iteration, y: currentAverageLoss });
          explorationRateValues.current.push({
            x: iteration,
            y: currentExplorationRate,
          });
          scoreValues.current.push({ x: iteration, y: currentScore });
          totalRewardValues.current.push({ x: iteration, y: totalReward });
          actionTimeValues.current.push({
            x: iteration,
            y: currentActionTime,
          });
          replayTimeValues.current.push({
            x: iteration,
            y: currentReplayTime,
          });

          // Render charts
          tfvis.render.linechart(
            { name: "Loss Over Time", tab: "Training Metrics" },
            { values: [lossValues.current] },
            {
              xLabel: "Iteration",
              yLabel: "Loss",
              width: 500,
              height: 300,
            }
          );

          tfvis.render.linechart(
            { name: "Exploration Rate Over Time", tab: "Training Metrics" },
            { values: [explorationRateValues.current] },
            {
              xLabel: "Iteration",
              yLabel: "Exploration Rate",
              width: 500,
              height: 300,
            }
          );

          tfvis.render.linechart(
            { name: "Score Over Time", tab: "Training Metrics" },
            { values: [scoreValues.current] },
            {
              xLabel: "Iteration",
              yLabel: "Score",
              width: 500,
              height: 300,
            }
          );

          tfvis.render.linechart(
            { name: "Total Reward Over Time", tab: "Training Metrics" },
            { values: [totalRewardValues.current] },
            {
              xLabel: "Iteration",
              yLabel: "Total Reward",
              width: 500,
              height: 300,
            }
          );

          tfvis.render.linechart(
            { name: "Action Time Over Time", tab: "Performance Metrics" },
            { values: [actionTimeValues.current] },
            {
              xLabel: "Iteration",
              yLabel: "Action Time (ms)",
              width: 500,
              height: 300,
            }
          );

          tfvis.render.linechart(
            { name: "Replay Time Over Time", tab: "Performance Metrics" },
            { values: [replayTimeValues.current] },
            {
              xLabel: "Iteration",
              yLabel: "Replay Time (ms)",
              width: 500,
              height: 300,
            }
          );

          gameEnvironment.reset(); // Now reset the game
          await tf.nextFrame(); // Yield control to the browser
        }
      }
    };

    trainAgent();
  }, [game]);

  return (
    <>
      <div
        style={{
          position: "absolute",
          left: "50%",
          transform: "translateX(-50%)",
          top: "20px",
          zIndex: 9999,
          color: "red",
        }}
      >
        <h2>
          Training the agent: iteration {iteration} of {trainingEpisodes}...
        </h2>
      </div>
      <FloatingContent>
        <div id="loss-chart"></div>
        <div id="exploration-rate-chart"></div>
        <div id="score-chart"></div>
        <div id="total-reward-chart"></div>
        <div id="action-time-chart"></div>
        <div id="replay-time-chart"></div>
      </FloatingContent>
    </>
  );
};

export default GameTrainer;

const FloatingContent = styled.div`
  position: absolute;
  top: 60px;
  right: 10px;
  padding: 10px;
  border-radius: 5px;
  max-height: 90vh;
  overflow-y: auto;
  color: black;
  z-index: 1000;
`;


File: game/index.tsx
import * as tf from "@tensorflow/tfjs";

import { FixedLengthArray, TriangleState } from "../helpers/types";
import {
  colsPerRowGrid,
  rowsOnGrid,
  colsPerRowShape,
  gridPadding,
} from "../helpers/constants";
import { buildNewShape } from "../helpers/triangles";

import { checkLineCollapse } from "./../game/collapse";
import { actionSize } from "../learn/configs";

import { isTriangleUp, initializeTrianglesGrid } from "../helpers/triangles";

import { combineMatrices } from "../helpers/calculations";

class Game {
  private historyTriangles: TriangleState[][] = [];
  private historyShapes: TriangleState[][][] = [];
  private historyScores: number[] = [0];
  private highScore: number;

  constructor() {
    this.highScore = parseInt(
      typeof window !== "undefined"
        ? localStorage.getItem("highScore") || "0"
        : "0",
      10
    );

    // Bind methods to this instance
    this.resetGame = this.resetGame.bind(this);
    this.addToScore = this.addToScore.bind(this);
    this.setShape = this.setShape.bind(this);
    this.setTriangles = this.setTriangles.bind(this);
    this.undo = this.undo.bind(this);
    this.getValidPositionsByShapes = this.getValidPositionsByShapes.bind(this);
    this.calculateHoveredAndValidPositions =
      this.calculateHoveredAndValidPositions.bind(this);
    this.getColRowByIndex = this.getColRowByIndex.bind(this);
    this.getTensorGameState = this.getTensorGameState.bind(this);

    this.resetGame();
  }

  public get triangles() {
    return this.historyTriangles[this.historyTriangles.length - 1];
  }

  public get shapes() {
    return this.historyShapes[this.historyShapes.length - 1];
  }

  public get score() {
    return this.historyScores[this.historyScores.length - 1];
  }

  public get currentHighScore() {
    return this.highScore;
  }

  public resetGame() {
    this.historyScores = [0];

    const initialTriangles: TriangleState[] =
      initializeTrianglesGrid(colsPerRowGrid);

    this.historyTriangles = [[...initialTriangles]];
    this.historyShapes = [Array.from({ length: 3 }, () => buildNewShape())];
  }

  public addToScore(points: number) {
    this.historyScores = [
      ...this.historyScores,
      this.historyScores[this.historyScores.length - 1] + points,
    ];
    this.updateHighScore();
  }

  public setShape(index: number, shape: TriangleState[]) {
    const newShapes = [...this.shapes];
    newShapes[index] = shape;
    this.historyShapes = [...this.historyShapes, newShapes];
    this.checkLineCollapse();
    if (this.shapes.flat().length === 0) {
      this.historyShapes.push([
        buildNewShape(),
        buildNewShape(),
        buildNewShape(),
      ]);

      const newHistoryShapes = this.historyShapes?.filter(
        (shapes) => shapes.flat().length > 0
      );

      this.historyShapes = newHistoryShapes;
    }
  }

  public setTriangles(
    action: (prevTriangles: TriangleState[]) => TriangleState[]
  ) {
    const lastTriangles = this.triangles;
    const newTriangles = action(lastTriangles);
    if (
      JSON.stringify(lastTriangles.map((t) => t.color)) !==
      JSON.stringify(newTriangles.map((t) => t.color))
    ) {
      this.historyTriangles = [...this.historyTriangles, newTriangles];
    }
  }

  public undo() {
    if (this.historyTriangles.length > 1 && this.historyShapes.length > 1) {
      let scoreOffset = 1;

      this.historyTriangles = this.historyTriangles.slice(0, -1);
      const collapsedTriangles = checkLineCollapse(this.triangles);
      if (collapsedTriangles.length > 0) {
        scoreOffset = 2;
        this.historyTriangles = this.historyTriangles.slice(0, -1);
      }

      this.historyShapes = this.historyShapes.slice(0, -1);
      this.historyScores = this.historyScores.slice(0, -scoreOffset);
    }
  }

  private updateHighScore() {
    const localStorageScore = parseInt(
      localStorage.getItem("highScore") || "0",
      10
    );
    const currentScore = this.score;
    if (currentScore > localStorageScore) {
      localStorage.setItem("highScore", currentScore.toString());
      this.highScore = currentScore;
    }
  }

  public getValidPositionsByShapes(): { col: number; row: number }[][] {
    return this.shapes.map((shape) => {
      const shapeIsEmtpy = shape.length === 0;
      const validPositions: { row: number; col: number }[] = [];

      this.triangles.forEach((triangle) => {
        const { isValid } = this.calculateHoveredAndValidPositions(
          null,
          triangle,
          true,
          shape
        ) ?? { isValid: false };

        if (isValid)
          validPositions.push({ row: triangle.row, col: triangle.col });
      });

      return validPositions;
    });
  }

  public calculateHoveredAndValidPositions(
    event: React.DragEvent | null,
    targetTriangle: TriangleState,
    isDropEvent = false,
    shape: TriangleState[] | null = null
  ) {
    event?.preventDefault();

    const shapeIsEmpty = !shape || shape?.length === 0;
    if (shapeIsEmpty) return;

    const firstTriangle = shape[0];
    const defaultColOffset = gridPadding[targetTriangle.row];
    const newHoveredTriangles = new Set<string>();
    const validPositions: { row: number; col: number }[] = [];

    const isValid = shape.every((triangle) => {
      const targetRow = targetTriangle.row + triangle.row - firstTriangle.row;
      const targetCol =
        targetTriangle.col +
        triangle.col -
        firstTriangle.col -
        gridPadding[targetRow] +
        defaultColOffset;
      const targetTriangleUp = isTriangleUp(
        { row: targetRow, col: targetCol },
        colsPerRowGrid
      );

      const shapeTriangleUp = isTriangleUp(triangle, colsPerRowShape);

      const validPosition =
        targetRow >= 0 &&
        targetRow < rowsOnGrid &&
        targetCol >= 0 &&
        targetCol < colsPerRowGrid[targetRow] &&
        !this.triangles.find(
          (t) => t.row === targetRow && t.col === targetCol && t.color != null
        ) &&
        targetTriangleUp === shapeTriangleUp;

      if (validPosition) {
        if (isDropEvent) {
          validPositions.push({ row: targetRow, col: targetCol });
        } else {
          newHoveredTriangles.add(`${targetRow}-${targetCol}`);
        }
      }

      return validPosition;
    });

    return { newHoveredTriangles, validPositions, isValid };
  }

  public getColRowByIndex(index: number): [number?, number?] {
    const triangle = this.triangles.find((triangle, i) => i === index);
    return [triangle?.col, triangle?.row];
  }

  private getEmptyGrid(): FixedLengthArray<FixedLengthArray<number, 15>, 8> {
    const emptyGrid = Array.from({ length: 8 }, () =>
      Array.from({ length: 15 }, () => 0)
    ) as FixedLengthArray<FixedLengthArray<number, 15>, 8>;

    return emptyGrid;
  }

  getEmptyShapeGrid(): FixedLengthArray<FixedLengthArray<number, 3>, 2> {
    return [
      [0, 0, 0],
      [0, 0, 0],
    ];
  }

  private getShapesGrid(): FixedLengthArray<
    FixedLengthArray<FixedLengthArray<number, 3>, 2>,
    3
  > {
    const shapesGrid: FixedLengthArray<
      FixedLengthArray<FixedLengthArray<number, 3>, 2>,
      3
    > = [
      this.getEmptyShapeGrid(),
      this.getEmptyShapeGrid(),
      this.getEmptyShapeGrid(),
    ];

    this.shapes.forEach((shape, shapeIndex) => {
      shape.forEach((triangle) => {
        const { row, col } = triangle;
        if (row < 8 && col < 15) {
          shapesGrid[shapeIndex][row][col] = 1;
        }
      });
    });

    return shapesGrid;
  }

  private getGridAvailability(): FixedLengthArray<
    FixedLengthArray<number, 15>,
    8
  > {
    const grid = this.getEmptyGrid();
    this.triangles.forEach((triangle) => {
      const { row, col: paddedCol, color } = triangle;
      const active = color != null;
      const rowOffset = gridPadding[row];
      const realCol = paddedCol + rowOffset;

      grid[row][realCol] = active ? 0 : 1;
    });

    return grid;
  }

  private getGriDownwards(): FixedLengthArray<FixedLengthArray<number, 15>, 8> {
    const grid = this.getEmptyGrid();
    this.triangles.forEach((triangle) => {
      const { row, col: paddedCol } = triangle;
      const isUp = isTriangleUp(triangle, colsPerRowGrid);

      const rowOffset = gridPadding[row];
      const realCol = paddedCol + rowOffset;

      grid[row][realCol] = !isUp ? 1 : 0;
    });

    return grid;
  }
  private getGridUpwards(): FixedLengthArray<FixedLengthArray<number, 15>, 8> {
    const grid = this.getEmptyGrid();
    this.triangles.forEach((triangle) => {
      const { row, col: paddedCol } = triangle;
      const isUp = isTriangleUp(triangle, colsPerRowGrid);

      const rowOffset = gridPadding[row];
      const realCol = paddedCol + rowOffset;

      grid[row][realCol] = isUp ? 1 : 0;
    });

    return grid;
  }

  private getShapesUpwardness(): FixedLengthArray<
    FixedLengthArray<number, 3>,
    2
  > {
    const shapeOrientation = this.getEmptyShapeGrid();
    const placeHolderShape = [
      { row: 0, col: 0, color: 0 },
      { row: 0, col: 1, color: 0 },
      { row: 0, col: 2, color: 0 },
      { row: 1, col: 0, color: 0 },
      { row: 1, col: 1, color: 0 },
      { row: 1, col: 2, color: 0 },
    ];

    placeHolderShape.forEach((triangle) => {
      const { row, col } = triangle;
      if (row < 8 && col < 15) {
        const isUp = isTriangleUp(triangle, colsPerRowShape);
        shapeOrientation[row][col] = isUp ? 1 : 0;
      }
    });

    return shapeOrientation;
  }
  private getShapesDownwards(): FixedLengthArray<
    FixedLengthArray<number, 3>,
    2
  > {
    const shapeOrientation = this.getEmptyShapeGrid();
    const placeHolderShape = [
      { row: 0, col: 0, color: 0 },
      { row: 0, col: 1, color: 0 },
      { row: 0, col: 2, color: 0 },
      { row: 1, col: 0, color: 0 },
      { row: 1, col: 1, color: 0 },
      { row: 1, col: 2, color: 0 },
    ];

    placeHolderShape.forEach((triangle) => {
      const { row, col } = triangle;
      if (row < 8 && col < 15) {
        const isUp = isTriangleUp(triangle, colsPerRowShape);
        shapeOrientation[row][col] = !isUp ? 1 : 0;
      }
    });

    return shapeOrientation;
  }

  private getTensorGridShape(): number[] {
    return [8, 15, 3];
  }
  private getTensorShapeShape(): number[] {
    return [2, 3, 3];
  }

  private getFittableByShapeGrid(): FixedLengthArray<
    FixedLengthArray<FixedLengthArray<number, 15>, 8>,
    3
  > {
    const emptyGrids: FixedLengthArray<
      FixedLengthArray<FixedLengthArray<number, 15>, 8>,
      3
    > = [this.getEmptyGrid(), this.getEmptyGrid(), this.getEmptyGrid()];

    const validPositionsByShapes = this.getValidPositionsByShapes();

    validPositionsByShapes.forEach((positions, positionIndex) =>
      positions.forEach(({ row, col }) => {
        const rowOffset = gridPadding[row];
        const realCol = col + rowOffset;
        emptyGrids[positionIndex][row][realCol] = 1;
      })
    );

    return emptyGrids;
  }

  public getTensorGameState(): tf.Tensor {
    const gridAvailability = this.getGridAvailability();
    const gridDownwards = this.getGriDownwards();
    const gridUpwards = this.getGridUpwards();

    const gridFeatures = combineMatrices([
      gridAvailability,
      gridDownwards,
      gridUpwards,
    ]);

    const gridTensor = tf
      .tensor(gridFeatures, [8, 15, 3])
      .reshape([1, 8, 15, 3]);

    return gridTensor;
  }

  public isGameOver() {
    return (
      this.shapes &&
      this.shapes.flat().length !== 0 &&
      this.shapes
        .filter((shape) => shape.length > 0)
        .every((shape) => !this.canPlaceAnyShape(shape))
    );
  }

  public canPlaceAnyShape(shape: TriangleState[]) {
    return this.triangles.some((triangle) => {
      const { isValid } =
        this.calculateHoveredAndValidPositions(null, triangle, true, shape) ??
        {};
      return isValid;
    });
  }

  public checkLineCollapse() {
    const collapsedTriangles = checkLineCollapse(this.triangles);

    if (collapsedTriangles.length > 0) {
      this.setTriangles((prevTriangles) =>
        prevTriangles.map((triangle) => {
          if (collapsedTriangles.find((t) => t.row === triangle.row)) {
            return {
              ...triangle,
              color: null,
            };
          }
          return triangle;
        })
      );
      this.addToScore(collapsedTriangles.length);
    }
  }

  public moveShapeToTriangle(col: number, row: number, shapeIndex: number) {
    const haveShapes = this.shapes && this.shapes.flat(5).length > 0;
    if (!haveShapes) return;
    const shape = this.shapes[shapeIndex];

    const targetTriangle = this.triangles.find(
      (t) => t.row === row && t.col === col
    );

    if (targetTriangle) {
      const { validPositions, isValid } =
        this.calculateHoveredAndValidPositions(
          null,
          targetTriangle,
          true,
          shape
        ) ?? {};

      if (isValid && shape != null && shape.length > 0) {
        const color = shape[0].color;
        this.addToScore(shape.length);
        this.setTriangles((prevTriangles) =>
          prevTriangles.map((triangle) =>
            validPositions?.some(
              (pos) => pos.row === triangle.row && pos.col === triangle.col
            )
              ? {
                  ...triangle,
                  color,
                }
              : triangle
          )
        );
        this.setShape(shapeIndex, []);
        return true;
      } else {
        return false;
      }
    }
  }
}

export default Game;


File: game/collapse.tsx
import { colsPerRowGrid } from "../helpers/constants";
import { removeDuplicatedTrianglesByColAndRow } from "../helpers/triangles";
import { TriangleState } from "../helpers/types";

const getHorizontalLineActive = (
  triangle: TriangleState,
  triangles: TriangleState[]
): TriangleState[] => {
  if (!isTriangleActivish(triangle)) return [];

  let index = 0;
  let neighborTail = triangle ? triangle.neighborhoodX : null;
  let tail =
    triangles.find(
      (triangle) =>
        triangle.row === neighborTail?.row && triangle.col === neighborTail?.col
    ) ?? null;

  let neighborHead = triangle ? triangle.neighborhoodY : null;

  let head =
    triangles.find(
      (triangle) =>
        triangle.row === neighborHead?.row && triangle.col === neighborHead?.col
    ) ?? null;

  const line = [triangle];

  while ((!!tail || !!head) && index < 100) {
    if (!tail && !head) return line;
    const tailActive = isTriangleActivish(tail);
    const headActive = isTriangleActivish(head);

    if (!tailActive || !headActive) {
      return [];
    }

    if (tail) line.push(tail);
    if (head) line.push(head);

    index += 1;
    neighborTail = tail ? tail.neighborhoodX : null;
    tail =
      triangles.find(
        (triangle) =>
          triangle.row === neighborTail?.row &&
          triangle.col === neighborTail?.col
      ) ?? null;

    neighborHead = head ? head.neighborhoodY : null;

    head =
      triangles.find(
        (triangle) =>
          triangle.row === neighborHead?.row &&
          triangle.col === neighborHead?.col
      ) ?? null;
  }

  return line;
};

const getDiagonalLineActive = (
  triangle: TriangleState,
  triangles: TriangleState[],
  directions: ("neighborhoodX" | "neighborhoodY" | "neighborhoodZ")[]
): TriangleState[] => {
  if (!isTriangleActivish(triangle)) return [];
  let index = 0;
  let neighborTail = triangle ? triangle[directions[index % 2]] : null;
  let tail =
    triangles.find(
      (triangle) =>
        triangle.row === neighborTail?.row && triangle.col === neighborTail?.col
    ) ?? null;

  let neighborHead = triangle ? triangle[directions[(index + 1) % 2]] : null;

  let head =
    triangles.find(
      (triangle) =>
        triangle.row === neighborHead?.row && triangle.col === neighborHead?.col
    ) ?? null;

  let line = [triangle];

  while (!!tail || !!head) {
    if (!tail && !head) return line;

    const tailActive = isTriangleActivish(tail);
    const headActive = isTriangleActivish(head);

    if (!tailActive || !headActive) return [];

    if (tail) line.push(tail);
    if (head) line.push(head);

    index += 1;
    neighborTail = tail ? tail[directions[index % 2]] : null;
    tail =
      triangles.find(
        (triangle) =>
          triangle.row === neighborTail?.row &&
          triangle.col === neighborTail?.col
      ) ?? null;

    neighborHead = head ? head[directions[(index + 1) % 2]] : null;

    head =
      triangles.find(
        (triangle) =>
          triangle.row === neighborHead?.row &&
          triangle.col === neighborHead?.col
      ) ?? null;
  }

  return line;
};
const isTriangleActivish = (triangle: TriangleState | null) =>
  triangle == null || triangle?.color != null;

export const checkLineCollapse = (
  triangles: TriangleState[]
): TriangleState[] => {
  const isFirstRow = (triangle: TriangleState) => triangle.row === 0;
  const isFirstCol = (triangle: TriangleState) => triangle.col === 0;
  const isColOdd = (triangle: TriangleState) => triangle.col % 2 !== 0;

  const isLastRow = (triangle: TriangleState) =>
    triangle.row === colsPerRowGrid.length - 1;

  const trianglesToCheckDiagonal = triangles?.filter(
    (triangle) =>
      (isFirstRow(triangle) && isColOdd(triangle)) ||
      (isLastRow(triangle) && isColOdd(triangle))
  );

  const trianglesToCheckHorizontal = triangles?.filter((triangle) =>
    isFirstCol(triangle)
  );

  const yzLineTriangles = trianglesToCheckDiagonal?.map((triangle) => {
    return getDiagonalLineActive(triangle, triangles, [
      "neighborhoodY",
      "neighborhoodZ",
    ]);
  });

  const zxLineTriangles = trianglesToCheckDiagonal?.map((triangle) =>
    getDiagonalLineActive(triangle, triangles, [
      "neighborhoodZ",
      "neighborhoodX",
    ])
  );

  const horizontalLineTriangles = trianglesToCheckHorizontal?.map((triangle) =>
    getHorizontalLineActive(triangle, triangles)
  );

  const lines = [
    ...(yzLineTriangles ?? []),
    ...(zxLineTriangles ?? []),
    ...(horizontalLineTriangles ?? []),
  ]
    .flat()
    .filter((_) => _ != null);

  const collapsedUniqueTriangles = removeDuplicatedTrianglesByColAndRow(lines);

  return collapsedUniqueTriangles;
};


File: helpers/formatters.ts
export function formatMatrix(matrix: number[][]): string {
  // Determine the maximum width of any number in the matrix for formatting
  const maxNumberWidth = Math.max(
    ...matrix.flat().map((num) => num.toString().length)
  );

  // Format each row and join them with newlines
  const formattedRows = matrix.map((row) => {
    return row
      .map((num) => num.toString().padStart(maxNumberWidth, " "))
      .join("");
  });

  return "\n" + formattedRows.join("\n") + "\n";
}


File: helpers/triangles.ts
import { getRandomColor, getRandomNumber } from "./calculations";
import {
  colsPerRowGrid,
  colsPerRowShape,
  gridPadding,
  rowsOnGrid,
} from "./constants";
import { TriangleState } from "./types";

export const initializeTrianglesGrid = (
  colsPerRowGrid: number[]
): TriangleState[] => {
  const rowsOnGrid = colsPerRowGrid.length;
  const initialTriangles: TriangleState[] = [];
  for (let row = 0; row < rowsOnGrid; row++) {
    const cols = colsPerRowGrid[row];
    for (let col = 0; col < cols; col++) {
      const triangle = {
        row,
        col,
        color: null,
        neighborhoodX: null,
        neighborhoodY: null,
        neighborhoodZ: null,
      };
      initialTriangles.push(triangle);
    }
  }

  initialTriangles.forEach((triangle) => {
    const neighbors = getNeighbors(triangle, initialTriangles, colsPerRowGrid);
    triangle.neighborhoodX = neighbors.X;
    triangle.neighborhoodY = neighbors.Y;
    triangle.neighborhoodZ = neighbors.Z;
  });
  return initialTriangles;
};

export const validateShapePosition = (
  targetTriangle: TriangleState,
  triangles: TriangleState[],
  shape: TriangleState[]
) => {
  const firstTriangle = shape[0];
  const defaultColOffset = gridPadding[targetTriangle.row];
  const newHoveredTriangles = new Set<string>();
  const validPositions: { row: number; col: number }[] = [];

  const isValid = shape.every((triangle) => {
    const targetRow = targetTriangle.row + triangle.row - firstTriangle.row;
    const targetCol =
      targetTriangle.col +
      triangle.col -
      firstTriangle.col -
      gridPadding[targetRow] +
      defaultColOffset;
    const targetTriangleUp = isTriangleUp(
      { row: targetRow, col: targetCol },
      colsPerRowGrid
    );

    const shapeTriangleUp = isTriangleUp(triangle, colsPerRowShape);

    const triangleUpMatch = targetTriangleUp === shapeTriangleUp;

    const isInBorderConstrains =
      targetRow >= 0 &&
      targetRow < rowsOnGrid &&
      targetCol >= 0 &&
      targetCol < colsPerRowGrid[targetRow];

    const isTrianglesGridOccupied = triangles.find(
      (t) => t.row === targetRow && t.col === targetCol && t.color != null
    );

    const validPosition =
      isInBorderConstrains && !isTrianglesGridOccupied && triangleUpMatch;

    return validPosition;
  });

  return { newHoveredTriangles, validPositions, isValid };
};

export const isTriangleUp = (
  triangle: { row: number; col: number },
  colsPerRow: number[]
) => {
  return triangle.row < colsPerRow.length / 2
    ? triangle.col % 2 === 0
    : triangle.col % 2 !== 0;
};

export const getIndexFromColAndRow = (
  col: number,
  row: number,
  colsPerRow: number[]
): number => {
  let index = 0;
  for (let i = 0; i < row; i++) {
    index += colsPerRow[i];
  }
  return index + col;
};

export const getRandomNotEmptyShapeElementIndex = (
  shapes: { row: number; col: number }[][]
): number => {
  const shapeIndex = getRandomNumber(0, shapes.length - 1);
  const selectedShape = shapes[shapeIndex];

  if (selectedShape.length === 0)
    return getRandomNotEmptyShapeElementIndex(shapes);
  return shapeIndex;
};

export const removeDuplicatedTrianglesByColAndRow = <
  T extends { col: number; row: number }
>(
  triangles: T[]
): T[] => {
  const triangleMap = new Map<string, T>();

  triangles.forEach((triangle: T) => {
    const key = `${triangle?.row}-${triangle?.col}`;
    triangleMap.set(key, triangle);
  });

  return Array.from(triangleMap.values());
};

export const getNeighbors = (
  triangle: TriangleState,
  triangles: TriangleState[],
  colsPerRow: number[]
) => {
  const { row, col } = triangle;
  const neighborOffsets = getNeighborOffsets(row, col, colsPerRow);

  const neighbors = neighborOffsets
    .map(([rowOffset, colOffset]) => {
      const neighborRow = row + rowOffset;
      const neighborCol = col + colOffset;

      return triangles.find(
        (triangle) =>
          triangle.row === neighborRow && triangle.col === neighborCol
      );
    })
    .filter((neighbor) => neighbor !== null);

  return {
    X: neighbors[0] || null,
    Y: neighbors[1] || null,
    Z: neighbors[2] || null,
  };
};

export const getNeighborOffsets = (
  row: number,
  col: number,
  colsPerRow: number[]
) => {
  const maxCols = Math.max(...colsPerRow);
  const padding = colsPerRow.map((cols) => (maxCols - cols) / 2);
  const currentTowColpadding = padding[row];

  const upperRowColpadding = padding[row - 1] - currentTowColpadding || 0;
  const downRowColpadding = padding[row + 1] - currentTowColpadding || 0;

  const isUp = isTriangleUp({ row, col }, colsPerRow);
  return isUp
    ? [
        [0, -1], // left
        [0, 1], // right
        [1, 0 - downRowColpadding], // bottom
      ]
    : [
        [0, -1], // left
        [0, 1], // right
        [-1, 0 - upperRowColpadding], // top
      ];
};

export const calculatePosition = (
  triangle: TriangleState,
  size: number,
  padding: number[]
) => {
  const triangleHeight = (size * Math.sqrt(3)) / 2;
  const halfSize = size / 2;
  const rowPadding = padding[triangle.row] * halfSize;
  const xSize = triangle.col * halfSize + rowPadding;
  const ySize = triangle.row * triangleHeight;
  const x = xSize + halfSize;
  const y = ySize + halfSize;
  return { x, y, triangleHeight };
};

export const calculateRowColFromPosition = (
  x: number,
  y: number,
  size: number,
  padding: number[]
) => {
  const triangleHeight = (size * Math.sqrt(3)) / 2;
  const halfSize = size / 2;

  const row = Math.floor(y / triangleHeight);
  const rowPadding = padding[row] * halfSize;
  const col = Math.floor((x - halfSize - rowPadding) / halfSize);

  return { row, col };
};

export const buildNewShape = (): TriangleState[] => {
  const shapeSize = getRandomNumber(1, 6);
  const color = getRandomColor();
  const newShape: TriangleState[] = [];
  const visited = new Set<string>();

  const initialRow = 1;
  const initialCol = getRandomNumber(0, 1);

  const initialTriangle: TriangleState = {
    row: initialRow,
    col: initialCol,
    color,
    neighborhoodX: null,
    neighborhoodY: null,
    neighborhoodZ: null,
  };

  newShape.push(initialTriangle);
  visited.add(`${initialRow}-${initialCol}`);

  const maxIterations = 50;
  for (let iteration = 0; iteration < maxIterations; iteration++) {
    if (newShape.length >= shapeSize) {
      break;
    }

    let currentTriangle = newShape[newShape.length - 1];
    const neighbors = getNeighbors(currentTriangle, newShape, colsPerRowShape);
    const availableNeighbors = Object.entries(neighbors)
      .filter(([key, value]) => value === null)
      .map(([key]) => key);

    if (availableNeighbors.length > 0) {
      const randomNeighbor =
        availableNeighbors[getRandomNumber(0, availableNeighbors.length - 1)];

      const neighborOffsets = getNeighborOffsets(
        currentTriangle.row,
        currentTriangle.col,
        colsPerRowShape
      );
      const [offsetX, offsetY] =
        neighborOffsets[["X", "Y", "Z"].indexOf(randomNeighbor)];

      const newRow = currentTriangle.row + offsetX;
      const newCol = currentTriangle.col + offsetY;

      if (
        newRow >= 0 &&
        newRow < rowsOnGrid &&
        newCol >= 0 &&
        newCol < colsPerRowShape[newRow]
      ) {
        const newTriangle: TriangleState = {
          row: newRow,
          col: newCol,
          color,
          neighborhoodX: null,
          neighborhoodY: null,
          neighborhoodZ: null,
        };

        if (randomNeighbor === "X") {
          currentTriangle.neighborhoodX = newTriangle;
          newTriangle.neighborhoodX = currentTriangle;
        } else if (randomNeighbor === "Y") {
          currentTriangle.neighborhoodY = newTriangle;
          newTriangle.neighborhoodY = currentTriangle;
        } else if (randomNeighbor === "Z") {
          currentTriangle.neighborhoodZ = newTriangle;
          newTriangle.neighborhoodZ = currentTriangle;
        }

        newShape.push(newTriangle);
        visited.add(`${newRow}-${newCol}`);
      }
    } else {
      break;
    }
  }

  return newShape;
};


File: helpers/calculations.ts
import { colors } from "./constants";

export function getRandomNumber(min: number, max: number) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

export const getRandomColor = () => {
  const colorIndex = getRandomNumber(0, colors.length - 1);
  return colors[colorIndex];
};

export function getRowColFromIndex(
  index: number,
  _numRows: number,
  numCols: number
): { row: number; col: number } {
  // Calculate the row and column
  const row = Math.floor(index / numCols);
  const col = index % numCols;

  return { row, col };
}

type Matrix<T> = T[][];

export function combineMatrices<T>(matrices: Matrix<T>[]): T[][][] {
  if (matrices.length === 0) return [];

  const rows = matrices[0].length;
  const cols = matrices[0][0].length;
  const depth = matrices.length;

  // Initialize the resulting 3D matrix
  const result: T[][][] = Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => Array.from({ length: depth }))
  );

  // Populate the result matrix with values from input matrices
  for (let d = 0; d < depth; d++) {
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        result[i][j][d] = matrices[d][i][j];
      }
    }
  }

  return result;
}

export function buildUnitByDepthCustom(
  initialY: number,
  finalY: number,
  maxValue: number,
  items: number
): number[] {
  // Define coefficients based on the constraints
  const c: number = initialY; // f(0) = initialY

  // Setup the system of equations to solve for 'a' and 'b'
  // f(1) = a + b + c = finalY
  // f(0.5) = 0.25a + 0.5b + c = maxValue (peak at x=0.5)
  const equations: [number[], number[]] = [
    [0.25, 0.5], // Coefficients for x^2 and x in the equation for maxValue
    [1, 1], // Coefficients for x^2 and x in the equation for finalY
  ];
  const constants: number[] = [
    maxValue - initialY, // Constant term for the equation for maxValue
    finalY - initialY, // Constant term for the equation for finalY
  ];

  // Solve the system of linear equations
  const [a, b]: number[] = solveLinearSystem(equations, constants);

  // Generate polynomial values
  const x: number[] = Array.from({ length: items }, (_, i) => i / (items - 1));
  const unit: number[] = x
    .map((x) => a * x * x + b * x + c)
    .map((val) => Math.round(val));
  console.log("unit");
  console.log(unit);

  return unit;
}

// Helper function to solve a system of linear equations using matrix operations
function solveLinearSystem(
  equations: [number[], number[]],
  constants: number[]
): number[] {
  // Using Cramer's Rule or any matrix library that can solve linear systems
  const [[a11, a12], [a21, a22]]: [number[], number[]] = equations;
  const [b1, b2]: number[] = constants;
  const det: number = a11 * a22 - a12 * a21; // Determinant of the matrix
  const detA: number = b1 * a22 - b2 * a12; // Determinant for 'a'
  const detB: number = a11 * b2 - a21 * b1; // Determinant for 'b'

  if (det === 0) throw new Error("No unique solution");

  return [detA / det, detB / det];
}


File: helpers/types.ts
import * as tf from "@tensorflow/tfjs";

export interface TriangleState {
  row: number;
  col: number;
  color: Colors | null;
  neighborhoodX: TriangleState | null;
  neighborhoodY: TriangleState | null;
  neighborhoodZ: TriangleState | null;
}

type Colors = string; // Update this based on your actual color type

export type TensorGameState = tf.Tensor;

export type Memory = {
  state: TensorGameState;
  action: number;
  reward: number;
  nextState: TensorGameState;
  done: boolean;
};


File: helpers/constants.ts
import { TriangleState } from "./types";

export const gridSize =
  typeof window === "undefined"
    ? 500
    : Math.min(window.innerWidth, window.innerHeight, 600) * 0.7;
export const colsPerRowGrid = [9, 11, 13, 15, 15, 13, 11, 9];
export const rowsOnGrid = colsPerRowGrid.length;
export const triangleSizeGrid = gridSize / (rowsOnGrid + 1);
export const maxGridCols = Math.max(...colsPerRowGrid);
export const gridPadding = colsPerRowGrid.map(
  (cols) => (maxGridCols - cols) / 2
);

export const colsPerRowGridPadded = [15, 15, 15, 15, 15, 15, 15, 15];

export const shapeSize = triangleSizeGrid * 3;
export const colsPerRowShape = [3, 3];
export const trianglesShapeSize = triangleSizeGrid;
export const maxShapeCols = Math.max(...colsPerRowShape);
export const shapePadding = colsPerRowShape.map(
  (cols) => (maxShapeCols - cols) / 2
);

export const colors = [
  "#ff006e",
  "#ffbe0b",
  "#fb5607",
  "#8338ec",
  "#3a86ff",
] as const;

export const invalidTriangle: TriangleState = {
  row: -1,
  col: -1,
  color: null,
  neighborhoodX: null,
  neighborhoodY: null,
  neighborhoodZ: null,
};

export const horizontalLines = [
  [3, 4, 5, 6, 7, 8, 9, 10, 11],
  [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27],
  [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43],
  [45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
  [60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74],
  [76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88],
  [92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102],
  [108, 109, 110, 111, 112, 113, 114, 115, 116],
];

export const diagonalXLines = [
  [3, 4, 17, 18, 31, 32, 45, 46, 60],
  [5, 6, 19, 20, 33, 34, 47, 48, 51, 52, 76],
  [7, 8, 21, 22, 35, 36, 49, 50, 63, 64, 77, 78, 92],
  [9, 10, 23, 24, 37, 38, 51, 52, 56, 66, 79, 80, 93, 94, 108],
  [11, 25, 26, 39, 40, 53, 54, 67, 68, 81, 82, 95, 96, 109],
  [27, 41, 42, 55, 56, 69, 70, 83, 84, 97, 98, 111, 112],
  [43, 57, 58, 71, 72, 85, 86, 99, 100, 113, 114],
  [59, 73, 74, 87, 88, 101, 102, 115, 116],
];

export const diagonalYLines = [
  [45, 60, 61, 76, 77, 82, 93, 108, 109],
  [31, 46, 47, 62, 63, 78, 79, 94, 95, 110, 111],
  [17, 32, 33, 48, 49, 64, 65, 80, 81, 96, 97, 112, 113],
  [3, 18, 19, 34, 35, 50, 51, 66, 67, 82, 83, 98, 99, 114, 115],
  [4, 5, 20, 21, 36, 37, 52, 53, 68, 69, 84, 85, 100, 101, 116],
  [6, 7, 22, 23, 38, 39, 54, 55, 70, 71, 86, 87, 102],
  [8, 9, 24, 25, 40, 41, 56, 57, 72, 73, 88],
  [10, 11, 26, 27, 42, 43, 58, 59, 74],
];

export const allLines = [
  ...diagonalXLines,
  ...diagonalYLines,
  ...horizontalLines,
  ...diagonalXLines.map((line) => line.map((i) => i * 2)),
  ...diagonalYLines.map((line) => line.map((i) => i * 2)),
  ...horizontalLines.map((line) => line.map((i) => i * 2)),
];


File: contexts/HexGridContext.tsx
"use client";

import { createContext, useContext, useRef, ReactNode } from "react";
import Game from "../game";

interface HexGridContextProps {
  game: Game;
}

const HexGridContext = createContext<HexGridContextProps | undefined>(
  undefined
);

export const HexGridProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const gameRef = useRef<Game>(new Game());

  return (
    <HexGridContext.Provider value={{ game: gameRef.current }}>
      {children}
    </HexGridContext.Provider>
  );
};

export const useHexGrid = () => {
  const context = useContext(HexGridContext);
  if (!context) {
    throw new Error("useHexGrid must be used within a HexGridProvider");
  }
  return context;
};


File: learn/DQNAgent.ts
// File: learn/DQNAgent.ts

import * as tf from "@tensorflow/tfjs";
import {
  explorationDecay,
  learningRate,
  updateTargetNetworkEveryNSteps,
  totalShapes,
  totalPositions,
  actionSize,
  batchSize,
} from "./configs";
import { Memory, TensorGameState } from "../helpers/types";

export class DQNAgent {
  public actionTimes: number[] = [];
  public replayTimes: number[] = [];
  private actionSize: number;
  public memory: Memory[];
  private replayBufferSize: number;

  private discountFactor: number;
  public explorationRate: number;
  private explorationMin: number;
  private explorationDecay: number;
  private learningRate: number;
  private model: tf.LayersModel;
  private targetModel: tf.LayersModel;
  private updateTargetNetworkFrequency: number;
  private trainStep: number;
  private totalLoss: number;
  private batchCount: number;
  private modelName: string;
  public averageLoss: number;

  constructor(actionSize: number) {
    this.modelName = "indexeddb://DQNAgentModel";
    this.actionSize = actionSize;
    this.memory = [];
    this.discountFactor = 0.99;
    this.explorationRate = 1.0;
    this.explorationMin = 0.02;
    this.replayBufferSize = 200_000;
    this.explorationDecay = explorationDecay;
    this.learningRate = learningRate;
    this.model = this.buildModel();
    this.targetModel = this.buildModel();
    this.updateTargetNetworkFrequency = updateTargetNetworkEveryNSteps;
    this.trainStep = 0;
    this.totalLoss = 0;
    this.batchCount = 0;
    this.averageLoss = 0;

    this.loadModelWeights().catch((err) => {
      console.log("No saved model found, starting with a new model.");
    });
  }

  buildModel() {
    const gridInputs = tf.input({ shape: [8, 15, 3], name: "grid_input" });

    // Convolutional layers for grid input
    let x = tf.layers
      .conv2d({ filters: 32, kernelSize: 3, activation: "relu" })
      .apply(gridInputs) as tf.SymbolicTensor;
    x = tf.layers.maxPooling2d({ poolSize: 2 }).apply(x) as tf.SymbolicTensor;
    x = tf.layers
      .conv2d({ filters: 64, kernelSize: 3, activation: "relu" })
      .apply(x) as tf.SymbolicTensor;
    x = tf.layers.flatten().apply(x) as tf.SymbolicTensor;

    // Fully connected layers
    x = tf.layers
      .dense({ units: 512, activation: "relu" })
      .apply(x) as tf.SymbolicTensor;
    x = tf.layers.dropout({ rate: 0.2 }).apply(x) as tf.SymbolicTensor;
    x = tf.layers
      .dense({ units: 256, activation: "relu" })
      .apply(x) as tf.SymbolicTensor;

    // Output layer
    const output = tf.layers
      .dense({ units: this.actionSize, activation: "linear", name: "output" })
      .apply(x) as tf.SymbolicTensor;

    const model = tf.model({ inputs: gridInputs, outputs: output });
    model.compile({
      loss: "meanSquaredError",
      optimizer: tf.train.adam(this.learningRate),
    });

    return model;
  }

  remember(
    state: TensorGameState,
    action: number,
    reward: number,
    nextState: TensorGameState,
    done: boolean
  ) {
    if (this.memory.length >= this.replayBufferSize) this.memory.shift();
    this.memory.push({ state, action, reward, nextState, done });
  }

  act(state: TensorGameState, validActionsMask: tf.Tensor): number {
    const start = Date.now(); // Start timing
    const gridInput = state;

    if (Math.random() <= this.explorationRate) {
      // Exploration: Randomly select a valid action
      const validActionsIndices = validActionsMask
        .dataSync()
        .map((value, index) => (value === 1 ? index : -1))
        .filter((index) => index !== -1);
      const randomIndex =
        validActionsIndices[
          Math.floor(Math.random() * validActionsIndices.length)
        ];
      return randomIndex;
    } else {
      // Exploitation: Predict the best action
      const predictedQValues = this.model.predict(
        gridInput.reshape([1, 8, 15, 3])
      ) as tf.Tensor;
      const maskedQValues = predictedQValues.add(validActionsMask.mul(-1e9));
      const actionIndex = maskedQValues.argMax(1).dataSync()[0];
      return actionIndex;
    }
  }

  async replay() {
    const start = Date.now();
    const minibatchSize = Math.min(batchSize, this.memory.length);
    const minibatch = this.memory.slice(-minibatchSize);
    let batchLoss = 0;

    const states = minibatch.map((m) => m.state.reshape([8, 15, 3]));
    const nextStates = minibatch.map((m) => m.nextState.reshape([8, 15, 3]));
    const actions = minibatch.map((m) => m.action);
    const rewards = minibatch.map((m) => m.reward);
    const dones = minibatch.map((m) => (m.done ? 0 : 1));

    const statesTensor = tf.stack(states);
    const nextStatesTensor = tf.stack(nextStates);

    const targetQs = tf.tidy(() => {
      const targetQValues = this.targetModel.predict(
        nextStatesTensor
      ) as tf.Tensor;
      const maxTargetQValues = targetQValues.max(1).mul(tf.tensor1d(dones));
      return tf
        .tensor1d(rewards)
        .add(maxTargetQValues.mul(this.discountFactor));
    });

    const masks = tf.oneHot(actions, this.actionSize);

    const optimizer = tf.train.adam(this.learningRate);
    const lossFunction = () => {
      const qValues = this.model.predict(statesTensor) as tf.Tensor;
      const qValuesWithMasks = qValues.mul(masks);
      const actionQValues = tf.sum(qValuesWithMasks, 1);
      const loss = tf.losses.meanSquaredError(targetQs, actionQValues);
      return loss;
    };

    const grads = tf.variableGrads(lossFunction);
    optimizer.applyGradients(grads.grads);

    batchLoss = grads.value.dataSync()[0];
    this.totalLoss += batchLoss;
    this.batchCount++;

    tf.dispose([
      statesTensor,
      nextStatesTensor,
      targetQs,
      masks,
      grads.value,
      ...Object.values(grads.grads),
    ]);

    this.trainStep++;
    if (this.trainStep % this.updateTargetNetworkFrequency === 0) {
      this.updateTargetNetwork();
      await this.saveModelWeights();
    }

    if (this.explorationRate > this.explorationMin) {
      this.explorationRate *= this.explorationDecay;
    }

    this.averageLoss = this.totalLoss / this.batchCount;

    const end = Date.now();
    const duration = end - start;
    this.replayTimes.push(duration);
  }

  async saveModelWeights() {
    await this.model.save(this.modelName);
    console.log(`Model saved to ${this.modelName}`);
  }

  async loadModelWeights() {
    try {
      const loadedModel = await tf.loadLayersModel(this.modelName);
      this.model.setWeights(loadedModel.getWeights());
      console.log(`Model weights loaded from ${this.modelName}`);
    } catch (error) {
      console.error("Failed to load model weights:", error);
      // Continue without throwing an error
    }
  }

  updateTargetNetwork() {
    this.targetModel.setWeights(this.model.getWeights());
  }
}


File: learn/GameEnvironment.ts
// File: learn/GameEnvironment.ts

import * as tf from "@tensorflow/tfjs";
import Game from "../game";
import { totalShapes, totalPositions, actionSize } from "./configs";
import { getIndexFromColAndRow } from "../helpers/triangles";
import { colsPerRowGridPadded, gridPadding } from "../helpers/constants";

export class GameEnvironment {
  private game: Game;
  private previousScore = 0;
  private howLongStaticScore = 0;

  constructor(game: Game) {
    this.game = game;
  }

  reset() {
    this.previousScore = 0;
    this.howLongStaticScore = 0;
    this.game.resetGame();
    return this.getTensorInputState();
  }

  getScore() {
    return this.game.score;
  }

  getTriangles() {
    return this.game.triangles;
  }

  getShapes() {
    return this.game.shapes;
  }

  getTensorInputState(): tf.Tensor {
    return this.game.getTensorGameState();
  }

  getValidActionsMask(): tf.Tensor {
    const validPositionsByShapes = this.game.getValidPositionsByShapes();
    const mask = new Array(actionSize).fill(0);

    validPositionsByShapes.forEach((positions, shapeIndex) => {
      positions.forEach(({ col, row }) => {
        const rowPadding = gridPadding[row];
        const paddedCol = col + rowPadding;
        const positionIndex = getIndexFromColAndRow(
          paddedCol,
          row,
          colsPerRowGridPadded
        );
        const actionIndex = shapeIndex * totalPositions + positionIndex;
        mask[actionIndex] = 1;
      });
    });

    return tf.tensor([mask]);
  }

  step(action: number) {
    const shapeIndex = Math.floor(action / totalPositions);
    const positionIndex = action % totalPositions;

    const { col: paddedCol, row } = this.getColRowFromIndex(
      positionIndex,
      colsPerRowGridPadded
    );

    const rowPadding = gridPadding[row];
    const col = paddedCol - rowPadding;

    const validPositions = this.game.getValidPositionsByShapes()[shapeIndex];
    const isValidMove = validPositions.some(
      (pos) => pos.col === col && pos.row === row
    );

    let reward = -1; // Default penalty for invalid move
    let done = false;

    if (isValidMove) {
      const moveSuccess = this.game.moveShapeToTriangle(col, row, shapeIndex);
      if (moveSuccess) {
        const score = this.getScore();
        const scoreDiff = score - this.previousScore;

        if (scoreDiff > 0) {
          reward = scoreDiff * 10; // Reward for collapsing lines
        } else {
          reward = 1; // Small reward for valid move
        }

        this.previousScore = score;
        this.howLongStaticScore = 0;
      } else {
        reward = -1; // Penalty for invalid move
        this.howLongStaticScore += 1;
      }
    } else {
      reward = -1; // Penalty for invalid move
      this.howLongStaticScore += 1;
    }

    if (this.game.isGameOver()) {
      done = true;
      reward = -10; // Penalty for game over
    }

    const nextState = this.getTensorInputState();
    return { nextState, reward, done };
  }

  getColRowFromIndex(
    index: number,
    colsPerRow: number[]
  ): { col: number; row: number } {
    let cumulativeCols = 0;
    for (let row = 0; row < colsPerRow.length; row++) {
      const colsInRow = colsPerRow[row];
      if (index < cumulativeCols + colsInRow) {
        const col = index - cumulativeCols;
        return { col, row };
      }
      cumulativeCols += colsInRow;
    }
    // If index is out of bounds
    return { col: -1, row: -1 };
  }
}


File: learn/configs.ts
// File: learn/configs.ts
export const totalShapes = 3;
export const totalPositions = 120; // Adjust based on your grid size
export const actionSize = totalShapes * totalPositions;

export const batchSize = 32;
export const trainingEpisodes = 10000;
export const learningRate = 0.001;
export const explorationDecay = 0.9990;
export const updateTargetNetworkEveryNSteps = 1000;
export const intervalToForceUpdate = 200;
export const replayEveryNSteps = 200;


