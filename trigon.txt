File: lib/registry.tsx
"use client";

import React, { useState } from "react";
import { useServerInsertedHTML } from "next/navigation";
import { ServerStyleSheet, StyleSheetManager } from "styled-components";

export default function StyledComponentsRegistry({
  children,
}: {
  children: React.ReactNode;
}) {
  // Only create stylesheet once with lazy initial state
  // x-ref: https://reactjs.org/docs/hooks-reference.html#lazy-initial-state
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet());

  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement();
    styledComponentsStyleSheet.instance.clearTag();
    return <>{styles}</>;
  });

  if (typeof window !== "undefined") return <>{children}</>;

  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  );
}


File: app/page.tsx
"use client";
import { HexGridProvider } from "./contexts/HexGridContext";
import dynamic from "next/dynamic";
const HexGrid = dynamic(() => import("@/app/components/HexGrid"), {
  ssr: false,
});
export default function Home() {
  return (
    <main>
      <HexGridProvider>
        <HexGrid />
      </HexGridProvider>
    </main>
  );
}


File: app/globals.css
:root {
  --max-width: 1100px;
  --border-radius: 12px;
  --font-mono: ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono",
    "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro",
    "Fira Mono", "Droid Sans Mono", "Courier New", monospace;

  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;

  --primary-glow: conic-gradient(
    from 180deg at 50% 50%,
    #16abff33 0deg,
    #0885ff33 55deg,
    #54d6ff33 120deg,
    #0071ff33 160deg,
    transparent 360deg
  );
  --secondary-glow: radial-gradient(
    rgba(255, 255, 255, 1),
    rgba(255, 255, 255, 0)
  );

  --tile-start-rgb: 239, 245, 249;
  --tile-end-rgb: 228, 232, 233;
  --tile-border: conic-gradient(
    #00000080,
    #00000040,
    #00000030,
    #00000020,
    #00000010,
    #00000010,
    #00000080
  );

  --callout-rgb: 238, 240, 241;
  --callout-border-rgb: 172, 175, 176;
  --card-rgb: 180, 185, 188;
  --card-border-rgb: 131, 134, 135;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;

    --primary-glow: radial-gradient(rgba(1, 65, 255, 0.4), rgba(1, 65, 255, 0));
    --secondary-glow: linear-gradient(
      to bottom right,
      rgba(1, 65, 255, 0),
      rgba(1, 65, 255, 0),
      rgba(1, 65, 255, 0.3)
    );

    --tile-start-rgb: 2, 13, 46;
    --tile-end-rgb: 2, 5, 19;
    --tile-border: conic-gradient(
      #ffffff80,
      #ffffff40,
      #ffffff30,
      #ffffff20,
      #ffffff10,
      #ffffff10,
      #ffffff80
    );

    --callout-rgb: 20, 20, 20;
    --callout-border-rgb: 108, 108, 108;
    --card-rgb: 100, 100, 100;
    --card-border-rgb: 200, 200, 200;
  }
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}


File: app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import StyledComponentsRegistry from "@/lib/registry";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <StyledComponentsRegistry>
      <html lang="en">
        <body className={inter.className}>{children}</body>
      </html>
    </StyledComponentsRegistry>
  );
}


File: app/utils/calculations.ts
import { colsPerRowShape, rowsOnGrid } from "./constants";
import { TriangleState } from "./types";

export const calculatePosition = (
  triangle: TriangleState,
  size: number,
  padding: number[]
) => {
  const triangleHeight = (size * Math.sqrt(3)) / 2;
  const halfSize = size / 2;
  const rowPadding = padding[triangle.row] * halfSize;
  const xSize = triangle.col * halfSize + rowPadding;
  const ySize = triangle.row * triangleHeight;
  const x = xSize + halfSize;
  const y = ySize + halfSize;
  return { x, y, triangleHeight };
};

export const isTriangleUp = (
  triangle: { row: number; col: number },
  colsPerRow: number[]
) => {
  return triangle.row < colsPerRow.length / 2
    ? triangle.col % 2 === 0
    : triangle.col % 2 !== 0;
};

export function getRandomNumber(min: number, max: number) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

const getNeighborOffsets = (row: number, col: number, colsPerRow: number[]) => {
  const maxCols = Math.max(...colsPerRow);
  const padding = colsPerRow.map((cols) => (maxCols - cols) / 2);

  const paddedCol = col + padding[row];
  const upperRowColpadding = padding[row - 1] || 0;
  const DownRowColpadding = padding[row + 1] || 0;
  const isUp = isTriangleUp({ row, col: paddedCol }, colsPerRow);
  return isUp
    ? [
        [0, -1], // left
        [0, 1], // right
        [1, 0 - DownRowColpadding], // bottom
      ]
    : [
        [0, -1], // left
        [0, 1], // right
        [-1, 0 - upperRowColpadding], // top
      ];
};

export const getNeighbors = (
  triangle: TriangleState,
  triangles: TriangleState[],
  colsPerRow: number[]
) => {
  const { row, col } = triangle;
  const neighborOffsets = getNeighborOffsets(row, col, colsPerRow);

  const neighbors = neighborOffsets
    .map(([rowOffset, colOffset]) => {
      const neighborRow = row + rowOffset;
      const neighborCol = col + colOffset;
      if (
        neighborRow >= 0 &&
        neighborRow < rowsOnGrid &&
        neighborCol >= 0 &&
        neighborCol < colsPerRowShape[neighborRow]
      ) {
        return triangles.find(
          (t) => t.row === neighborRow && t.col === neighborCol
        );
      }
      return null;
    })
    .filter((neighbor) => neighbor !== null) as TriangleState[];

  return {
    X: neighbors[0] || null,
    Y: neighbors[1] || null,
    Z: neighbors[2] || null,
  };
};

export const buildNewShape = (): TriangleState[] => {
  const shapeSize = Math.max(getRandomNumber(1, 5), getRandomNumber(1, 5));

  const newShape: TriangleState[] = [];
  const visited = new Set<string>();

  const initialRow = getRandomNumber(1, 2);
  const initialCol = getRandomNumber(2, 3);

  const initialTriangle: TriangleState = {
    row: initialRow,
    col: initialCol,
    isActive: true,
    neighborhoodX: null,
    neighborhoodY: null,
    neighborhoodZ: null,
  };

  newShape.push(initialTriangle);
  visited.add(`${initialRow}-${initialCol}`);

  // Use a finite loop with a limit on the number of iterations
  const maxIterations = 10;
  for (let iteration = 0; iteration < maxIterations; iteration++) {
    if (newShape.length >= shapeSize) {
      break;
    }

    let currentTriangle = newShape[newShape.length - 1];
    const neighbors = getNeighbors(currentTriangle, newShape, colsPerRowShape);
    const availableNeighbors = Object.entries(neighbors)
      .filter(([key, value]) => value === null)
      .map(([key]) => key);

    if (availableNeighbors.length > 0) {
      const randomNeighbor =
        availableNeighbors[getRandomNumber(0, availableNeighbors.length - 1)];

      const neighborOffsets = getNeighborOffsets(
        currentTriangle.row,
        currentTriangle.col,
        colsPerRowShape
      );
      const [offsetX, offsetY] =
        neighborOffsets[["X", "Y", "Z"].indexOf(randomNeighbor)];

      const newRow = currentTriangle.row + offsetX;
      const newCol = currentTriangle.col + offsetY;

      if (
        newRow >= 0 &&
        newRow < rowsOnGrid &&
        newCol >= 0 &&
        newCol < colsPerRowShape[newRow]
      ) {
        const newTriangle: TriangleState = {
          row: newRow,
          col: newCol,
          isActive: true,
          neighborhoodX: null,
          neighborhoodY: null,
          neighborhoodZ: null,
        };

        // Update the neighbor references
        if (randomNeighbor === "X") {
          currentTriangle.neighborhoodX = newTriangle;
          newTriangle.neighborhoodX = currentTriangle;
        } else if (randomNeighbor === "Y") {
          currentTriangle.neighborhoodY = newTriangle;
          newTriangle.neighborhoodY = currentTriangle;
        } else if (randomNeighbor === "Z") {
          currentTriangle.neighborhoodZ = newTriangle;
          newTriangle.neighborhoodZ = currentTriangle;
        }

        newShape.push(newTriangle);
        visited.add(`${newRow}-${newCol}`);
      }
    } else {
      break;
    }
  }

  return newShape;
};


File: app/utils/types.ts
export interface TriangleState {
  row: number;
  col: number;
  isActive: boolean;
  neighborhoodX: TriangleState | null;
  neighborhoodY: TriangleState | null;
  neighborhoodZ: TriangleState | null;
}


File: app/utils/constants.ts
export const gridSize = 400;
export const colsPerRowGrid = [9, 11, 13, 15, 15, 13, 11, 9];
export const rowsOnGrid = colsPerRowGrid.length;
export const triangleSizeGrid = gridSize / (rowsOnGrid + 1);
export const maxGridCols = Math.max(...colsPerRowGrid);
export const gridPadding = colsPerRowGrid.map(
  (cols) => (maxGridCols - cols) / 2
);

export const shapeSize = 200;
export const colsPerRowShape = [5, 7, 7, 5];
export const trianglesShapeSize = shapeSize / (rowsOnGrid + 1);
export const maxShapeCols = Math.max(...colsPerRowShape);
export const shapePadding = colsPerRowShape.map(
  (cols) => (maxShapeCols - cols) / 2
);


File: app/components/HexGrid.tsx
"use client";
import React from "react";
import HexGridRender from "./HexGridRender";

const HexGrid: React.FC = () => {
  return (
    <div style={{ position: "relative" }}>
      <HexGridRender />
    </div>
  );
};

export default HexGrid;


File: app/components/Triangle.tsx
import { styled } from "styled-components";

export const Triangle = styled.div<{
  $x: number;
  $y: number;
  $size: number;
  $triangleHeight: number;
  $isUp: boolean;
  $isActive: boolean;
  $isHovering: boolean;
  $zIndex: number;
  $rowIndex: number;
}>`
  position: absolute;
  width: 0;
  height: 0;
  left: ${({ $x }) => $x}px;
  top: ${({ $y, $rowIndex }) => $y + $rowIndex * 2}px;
  z-index: ${({ $zIndex }) => $zIndex};
  pointer-events: auto;
  border-left: ${({ $size }) => $size / 2 - 2}px solid transparent;
  border-right: ${({ $size }) => $size / 2 - 2}px solid transparent;
  ${({ $isUp, $triangleHeight, $isActive, $isHovering }) =>
    $isUp
      ? `
    border-bottom: ${$triangleHeight}px solid ${
          $isHovering ? "yellow" : $isActive ? "green" : "red"
        };
  `
      : `
    border-top: ${$triangleHeight}px solid ${
          $isHovering ? "yellow" : $isActive ? "green" : "red"
        };
  `}
`;


File: app/components/HexGridRender.tsx
// File: app/components/HexGridRender.tsx
import React, { useEffect, useMemo, useState } from "react";
import { useHexGrid } from "../contexts/HexGridContext";
import {
  buildNewShape,
  calculatePosition,
  getNeighbors,
  isTriangleUp,
} from "../utils/calculations";
import {
  colsPerRowGrid,
  triangleSizeGrid,
  gridSize,
  colsPerRowShape,
  gridPadding,
} from "../utils/constants";
import { TriangleState } from "../utils/types";
import styled from "styled-components";
import { Triangle } from "./Triangle";
import ShapeRenderer from "./ShapeRenderer";

const Container = styled.div`
  display: flex;
  position: relative;
  flex-direction: column;
  width: 100vw;
  height: 100vh;
  gap: 2rem;
  border: 1px solid white;
  justify-content: center;
  align-items: center;
`;

const GridContainer = styled.div`
  position: relative;
  width: ${gridSize}px;
  height: ${gridSize}px;
  border: 1px solid blue;
`;

const OptionsContainer = styled.div`
  position: relative;
  width: 50%;
  height: 4rem;
  border: 1px solid green;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  justify-content: space-around;
  align-items: center;
`;

const Option = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  border: 2px dotted yellow;
  height: 100%;
  cursor: pointer;
`;

const HexGridRender: React.FC = () => {
  const { triangles, setTriangles } = useHexGrid();
  const [draggedShape, setDraggedShape] = useState<TriangleState[] | null>(
    null
  );
  const hexGridRows = colsPerRowGrid.length;
  const [hoveredTriangles, setHoveredTriangles] = useState<Set<string>>(
    new Set()
  );

  const handleTriangleClick = (triangle: TriangleState) => {
    console.log("Triangle clicked", triangle);

    setTriangles((prevTriangles) =>
      prevTriangles.map((t) =>
        t.row === triangle.row && t.col === triangle.col
          ? { ...t, isActive: !t.isActive }
          : t
      )
    );
  };

  const handleDragStart = (event: React.DragEvent, shape: TriangleState[]) => {
    setDraggedShape(shape);
  };

  const handleDragOver = (
    event: React.DragEvent,
    targetTriangle: TriangleState
  ) => {
    event.preventDefault();
    if (!draggedShape) return;

    const newHoveredTriangles = new Set<string>();
    const canDrop = draggedShape.every((triangle) => {
      const targetRow = targetTriangle.row + triangle.row - draggedShape[0].row;
      const targetCol = targetTriangle.col + triangle.col - draggedShape[0].col;

      const targetTriangleUp = isTriangleUp(
        { row: targetRow, col: targetCol },
        colsPerRowGrid
      );

      const shapeTriangleUp = isTriangleUp(triangle, colsPerRowShape);

      console.log({ targetTriangleUp, shapeTriangleUp });

      const validPosition =
        targetRow >= 0 &&
        targetRow < hexGridRows &&
        targetCol >= 0 &&
        targetCol < colsPerRowGrid[targetRow] &&
        !triangles.find(
          (t) => t.row === targetRow && t.col === targetCol && t.isActive
        ) &&
        targetTriangleUp === shapeTriangleUp;

      if (validPosition) {
        newHoveredTriangles.add(`${targetRow}-${targetCol}`);
      }

      return validPosition;
    });

    console.log({ canDrop });

    if (canDrop) {
      setHoveredTriangles(newHoveredTriangles);
    } else {
      setHoveredTriangles(new Set());
    }
  };

  const handleDrop = (
    event: React.DragEvent,
    targetTriangle: TriangleState
  ) => {
    event.preventDefault();
    if (!draggedShape) return;

    const canDrop = draggedShape.every((triangle) => {
      const targetRow = targetTriangle.row + triangle.row - draggedShape[0].row;
      const targetCol = targetTriangle.col + triangle.col - draggedShape[0].col;

      const targetTriangleUp = isTriangleUp(
        { row: targetRow, col: targetCol },
        colsPerRowGrid
      );
      const shapeTriangleUp = isTriangleUp(triangle, colsPerRowGrid);

      return (
        targetRow >= 0 &&
        targetRow < hexGridRows &&
        targetCol >= 0 &&
        targetCol < colsPerRowGrid[targetRow] &&
        !triangles.find(
          (t) => t.row === targetRow && t.col === targetCol && t.isActive
        ) &&
        targetTriangleUp === shapeTriangleUp
      );
    });

    if (canDrop) {
      setTriangles((prevTriangles) =>
        prevTriangles.map((t) => {
          const shapeTriangle = draggedShape.find(
            (triangle) =>
              t.row ===
                targetTriangle.row + triangle.row - draggedShape[0].row &&
              t.col === targetTriangle.col + triangle.col - draggedShape[0].col
          );
          return shapeTriangle ? { ...t, isActive: true } : t;
        })
      );
    }

    setHoveredTriangles(new Set());
    setDraggedShape(null);
  };

  const handleDragLeave = () => {
    setHoveredTriangles(new Set());
  };

  const shapes = useMemo(
    () => Array.from({ length: 3 }, () => buildNewShape()),
    []
  );

  return (
    <Container>
      <div>Current Score / Best Score</div>
      <GridContainer>
        {triangles.map((triangle) => {
          const { x, y, triangleHeight } = calculatePosition(
            triangle,
            triangleSizeGrid,
            gridPadding
          );
          const isUp = isTriangleUp(triangle, colsPerRowGrid);
          const zIndex = colsPerRowGrid[triangle.row] - triangle.col;
          const isHovered = hoveredTriangles.has(
            `${triangle.row}-${triangle.col}`
          );

          return (
            <Triangle
              key={`grid-triangle-${triangle.row}-${triangle.col}`}
              $x={x}
              $y={y}
              $size={triangleSizeGrid}
              $triangleHeight={triangleHeight}
              $isUp={isUp}
              $isActive={triangle.isActive}
              $zIndex={zIndex}
              $rowIndex={triangle.row}
              $isHovering={isHovered}
              onClick={() => handleTriangleClick(triangle)}
              onDrop={(event) => handleDrop(event, triangle)}
              onDragOver={(event) => handleDragOver(event, triangle)}
              onDragLeave={handleDragLeave}
            />
          );
        })}
      </GridContainer>
      <OptionsContainer>
        {shapes.map((shape, index) => (
          <Option onClick={() => console.log({ index, shape })} key={index}>
            <ShapeRenderer shape={shape} onDragStart={handleDragStart} />
          </Option>
        ))}
      </OptionsContainer>
    </Container>
  );
};

export default HexGridRender;


File: app/components/ShapeRenderer.tsx
"use client";
import React from "react";
import { TriangleState } from "../utils/types";
import { calculatePosition, isTriangleUp } from "../utils/calculations";
import styled from "styled-components";
import { Triangle } from "./Triangle";
import {
  colsPerRowShape,
  shapePadding,
  shapeSize,
  trianglesShapeSize,
} from "../utils/constants";

const ShapeContainer = styled.div`
  display: flex;
  position: relative;
  flex-direction: column;
  width: ${shapeSize}px;
  height: ${shapeSize}px;
  justify-content: center;
  align-items: center;
  border: 2px dotted white;
`;

interface ShapeRendererProps {
  shape: TriangleState[];
  onDragStart: (event: React.DragEvent, shape: TriangleState[]) => void;
}

const ShapeRenderer: React.FC<ShapeRendererProps> = ({
  shape,
  onDragStart,
}) => {
  return (
    <ShapeContainer
      draggable
      onDragStart={(event) => onDragStart(event, shape)}
    >
      {shape.map((triangle, index) => {
        const { x, y, triangleHeight } = calculatePosition(
          triangle,
          trianglesShapeSize,
          shapePadding
        );
        const isUp = isTriangleUp(triangle, colsPerRowShape);
        const zIndex = colsPerRowShape[triangle.row] - triangle.col;

        return (
          <Triangle
            key={`shape-triangle-${triangle.row}-${triangle.col}-${index}`}
            $x={x}
            $y={y}
            $size={trianglesShapeSize}
            $triangleHeight={triangleHeight}
            $isUp={isUp}
            $isActive={triangle.isActive}
            $zIndex={zIndex}
            $rowIndex={triangle.row}
            $isHovering={true}
            onClick={() => {}}
          />
        );
      })}
    </ShapeContainer>
  );
};

export default ShapeRenderer;


File: app/contexts/HexGridContext.tsx
"use client";

import React, { createContext, useState, useContext, useEffect } from "react";
import { TriangleState } from "../utils/types";
import {
  colsPerRowGrid,
  rowsOnGrid,
  triangleSizeGrid,
} from "../utils/constants";

interface HexGridContextProps {
  triangles: TriangleState[];
  setTriangles: React.Dispatch<React.SetStateAction<TriangleState[]>>;
  hoveredTriangle: TriangleState | null;
  colsPerRow: number[];
  size: number;
  setHoveredTriangle: React.Dispatch<
    React.SetStateAction<TriangleState | null>
  >;
  padding: number[];
}

const HexGridContext = createContext<HexGridContextProps | undefined>(
  undefined
);

export const HexGridProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [triangles, setTriangles] = useState<TriangleState[]>([]);
  const [hoveredTriangle, setHoveredTriangle] = useState<TriangleState | null>(
    null
  );

  useEffect(() => {
    const initializeTriangles = () => {
      const triangleStates: TriangleState[] = [];

      for (let row = 0; row < rowsOnGrid; row++) {
        const cols = colsPerRowGrid[row];
        for (let col = 0; col < cols; col++) {
          const triangle: TriangleState = {
            row,
            col,
            isActive: false,
            neighborhoodX: null,
            neighborhoodY: null,
            neighborhoodZ: null,
          };
          triangleStates.push(triangle);
        }
      }

      // Assign neighbors after triangles are initialized
      triangleStates.forEach((triangle) => {
        const neighbors = getNeighbors(triangle, triangleStates);
        triangle.neighborhoodX = neighbors.X;
        triangle.neighborhoodY = neighbors.Y;
        triangle.neighborhoodZ = neighbors.Z;
      });

      setTriangles(triangleStates);
    };

    initializeTriangles();
  }, []);

  const getNeighbors = (
    triangle: TriangleState,
    triangles: TriangleState[]
  ) => {
    const { row, col } = triangle;

    const isUp = (row + col) % 2 === 0;

    const neighbors = {
      X: null as TriangleState | null,
      Y: null as TriangleState | null,
      Z: null as TriangleState | null,
    };

    const neighborOffsets = isUp
      ? [
          [0, -1],
          [0, 1],
          [1, 0],
        ]
      : [
          [0, -1],
          [0, 1],
          [-1, 0],
        ];

    neighborOffsets.forEach(([rowOffset, colOffset], index) => {
      const neighborRow = row + rowOffset;
      const neighborCol = col + colOffset;

      if (neighborRow >= 0 && neighborRow < rowsOnGrid) {
        const neighborCols = colsPerRowGrid[neighborRow];
        if (neighborCol >= 0 && neighborCol < neighborCols) {
          const neighborIndex = triangles.findIndex(
            (triangle) =>
              triangle.row === neighborRow && triangle.col === neighborCol
          );
          neighbors[Object.keys(neighbors)[index] as keyof typeof neighbors] =
            triangles[neighborIndex];
        }
      }
    });

    return neighbors;
  };

  return (
    <HexGridContext.Provider
      value={{
        triangles,
        setTriangles,
        hoveredTriangle,
        setHoveredTriangle,
        colsPerRow: colsPerRowGrid,
        size: triangleSizeGrid,
      }}
    >
      {children}
    </HexGridContext.Provider>
  );
};

export const useHexGrid = () => {
  const context = useContext(HexGridContext);
  if (!context) {
    throw new Error("useHexGrid must be used within a HexGridProvider");
  }
  return context;
};


