File: app/page.tsx
"use client"
import HexGrid from "@/app/components/HexGrid";
import { HexGridProvider } from "./contexts/HexGridContext";

export default function Home() {
  return (
    <main>
      <HexGridProvider>
        <HexGrid />
      </HexGridProvider>
    </main>
  );
}


File: app/globals.css
:root {
  --max-width: 1100px;
  --border-radius: 12px;
  --font-mono: ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono",
    "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro",
    "Fira Mono", "Droid Sans Mono", "Courier New", monospace;

  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;

  --primary-glow: conic-gradient(
    from 180deg at 50% 50%,
    #16abff33 0deg,
    #0885ff33 55deg,
    #54d6ff33 120deg,
    #0071ff33 160deg,
    transparent 360deg
  );
  --secondary-glow: radial-gradient(
    rgba(255, 255, 255, 1),
    rgba(255, 255, 255, 0)
  );

  --tile-start-rgb: 239, 245, 249;
  --tile-end-rgb: 228, 232, 233;
  --tile-border: conic-gradient(
    #00000080,
    #00000040,
    #00000030,
    #00000020,
    #00000010,
    #00000010,
    #00000080
  );

  --callout-rgb: 238, 240, 241;
  --callout-border-rgb: 172, 175, 176;
  --card-rgb: 180, 185, 188;
  --card-border-rgb: 131, 134, 135;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;

    --primary-glow: radial-gradient(rgba(1, 65, 255, 0.4), rgba(1, 65, 255, 0));
    --secondary-glow: linear-gradient(
      to bottom right,
      rgba(1, 65, 255, 0),
      rgba(1, 65, 255, 0),
      rgba(1, 65, 255, 0.3)
    );

    --tile-start-rgb: 2, 13, 46;
    --tile-end-rgb: 2, 5, 19;
    --tile-border: conic-gradient(
      #ffffff80,
      #ffffff40,
      #ffffff30,
      #ffffff20,
      #ffffff10,
      #ffffff10,
      #ffffff80
    );

    --callout-rgb: 20, 20, 20;
    --callout-border-rgb: 108, 108, 108;
    --card-rgb: 100, 100, 100;
    --card-border-rgb: 200, 200, 200;
  }
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}


File: app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}


File: app/utils/draw.ts
import p5 from "p5";
import { TriangleState } from "./types";
import { isTriangleUp } from "./calculations";
import { colsPerRow } from "./constants";

export const drawTriangleUp = (
  p: p5,
  x: number,
  y: number,
  size: number,
  triangleHeight: number
) => {
  p.beginShape();
  p.vertex(x, y - triangleHeight / 2);
  p.vertex(x - size / 2, y + triangleHeight / 2);
  p.vertex(x + size / 2, y + triangleHeight / 2);
  p.endShape(p.CLOSE);
};

export const drawTriangleDown = (
  p: p5,
  x: number,
  y: number,
  size: number,

  triangleHeight: number
) => {
  p.beginShape();
  p.vertex(x, y + triangleHeight / 2);
  p.vertex(x - size / 2, y - triangleHeight / 2);
  p.vertex(x + size / 2, y - triangleHeight / 2);
  p.endShape(p.CLOSE);
};

export const drawTriangle = (
  p: p5,
  triangle: TriangleState,
  x: number,
  y: number,
  size: number,
  triangleHeight: number
) => {
  if (triangle.isActive) {
    p.fill(0, 255, 0); // Active triangle
  } else {
    p.fill(255, 0, 0); // Inactive triangle
  }

  if (isTriangleUp(triangle, colsPerRow)) {
    drawTriangleUp(p, x, y, size, triangleHeight);
  } else {
    drawTriangleDown(p, x, y, size, triangleHeight);
  }
};


File: app/utils/calculations.ts
import { colsPerRow } from "./constants";
import { TriangleState } from "./types";

const isPointInTriangle = (
  px: number,
  py: number,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  x3: number,
  y3: number
): boolean => {
  const dX = px - x3;
  const dY = py - y3;
  const dX21 = x3 - x2;
  const dY12 = y2 - y3;
  const D = dY12 * (x1 - x3) + dX21 * (y1 - y3);
  const s = dY12 * dX + dX21 * dY;
  const t = (y3 - y1) * dX + (x1 - x3) * dY;
  const invD = 1 / D;
  return s >= 0 && t >= 0 && (s + t) * invD <= 1;
};

export const calculatePosition = (
  triangle: TriangleState,
  size: number,
  padding: number[]
) => {
  const triangleHeight = (size * Math.sqrt(3)) / 2;
  const halfSize = size / 2;
  const rowPadding = padding[triangle.row] * halfSize;
  const xSize = triangle.col * halfSize + rowPadding;
  const ySize = triangle.row * triangleHeight;
  const x = xSize + halfSize;
  const y = ySize + halfSize;
  return { x, y, triangleHeight };
};

export const isTriangleUp = (triangle: TriangleState, colsPerRow: number[]) => {
  return triangle.row <= (colsPerRow.length - 1) / 2
    ? triangle.col % 2 === 0
    : triangle.col % 2 !== 0;
};

export const getTriangleAtPosition = (
  x: number,
  y: number,
  triangles: TriangleState[],
  size: number,
  padding: number[]
): TriangleState | null => {
  for (const triangle of triangles) {
    const {
      x: triangleX,
      y: triangleY,
      triangleHeight,
    } = calculatePosition(triangle, size, padding);
    const halfSize = size / 2;

    let x1, y1, x2, y2, x3, y3;

    if (isTriangleUp(triangle, colsPerRow)) {
      x1 = triangleX - halfSize;
      y1 = triangleY + triangleHeight / 2;
      x2 = triangleX + halfSize;
      y2 = triangleY + triangleHeight / 2;
      x3 = triangleX;
      y3 = triangleY - triangleHeight / 2;
    } else {
      x1 = triangleX - halfSize;
      y1 = triangleY - triangleHeight / 2;
      x2 = triangleX + halfSize;
      y2 = triangleY - triangleHeight / 2;
      x3 = triangleX;
      y3 = triangleY + triangleHeight / 2;
    }

    if (isPointInTriangle(x, y, x1, y1, x2, y2, x3, y3)) {
      return triangle;
    }
  }
  return null;
};


File: app/utils/types.ts
export interface TriangleState {
  row: number;
  col: number;
  isActive: boolean;
  neighborhoodX: TriangleState | null;
  neighborhoodY: TriangleState | null;
  neighborhoodZ: TriangleState | null;
}


File: app/utils/constants.ts
export const colsPerRow = [5, 7, 7, 5];
export const size = 50;
export const rows = colsPerRow.length;


File: app/components/HexGrid.tsx
"use client";
import React from "react";
import HexGridRender from "./HexGridRender";

const HexGrid: React.FC = () => {
  return (
    <div style={{ position: "relative" }}>
      <HexGridRender />
    </div>
  );
};

export default HexGrid;


File: app/components/HexGridRender.tsx
"use client";

import React, { useRef, useEffect } from "react";
import p5 from "p5";
import { useHexGrid } from "../contexts/HexGridContext";
import { drawTriangle } from "@/app/utils/draw";
import {
  calculatePosition,
  getTriangleAtPosition,
} from "../utils/calculations";
const canvasSize = 300;

const HexGridRender: React.FC = () => {
  const canvasRef = useRef<HTMLDivElement>(null);
  const { triangles, setTriangles, size, colsPerRow, padding } = useHexGrid();
  const p5Instance = useRef<p5 | null>(null);

  useEffect(() => {
    const sketch = (p: p5) => {
      p.setup = () => {
        p.createCanvas(canvasSize, canvasSize);
        p.noLoop();
      };

      p.draw = () => {
        p.background(0);
        p.stroke(255);
        p.strokeWeight(1);
        p.noFill();

        // Draw the triangles
        triangles.forEach((triangle) => {
          const { x, y, triangleHeight } = calculatePosition(
            triangle,
            size,
            padding
          );
          drawTriangle(p, triangle, x, y, size, triangleHeight);
        });
      };

      p.mousePressed = () => {
        const triangle = getTriangleAtPosition(
          p.mouseX,
          p.mouseY,
          triangles,
          size,
          padding
        );
        if (triangle) {
          console.log("Triangle clicked:", triangle);

          // Update the triangle's state to active
          setTriangles((prevTriangles) =>
            prevTriangles.map((t) =>
              t.row === triangle.row && t.col === triangle.col
                ? { ...t, isActive: true }
                : t
            )
          );

          // Redraw the canvas to reflect the state change
          p.redraw();
        } else {
          console.log("No triangle at this position.");
        }
      };
    };

    p5Instance.current = new p5(sketch, canvasRef.current!);
    return () => {
      p5Instance.current?.remove();
    };
  }, [triangles, size, colsPerRow, padding, setTriangles]);

  return <div ref={canvasRef} />;
};

export default HexGridRender;


File: app/contexts/HexGridContext.tsx
"use client";

import React, { createContext, useState, useContext, useEffect } from "react";
import { TriangleState } from "../utils/types";
import { colsPerRow, rows, size } from "../utils/constants";

interface HexGridContextProps {
  triangles: TriangleState[];
  setTriangles: React.Dispatch<React.SetStateAction<TriangleState[]>>;
  hoveredTriangle: TriangleState | null;
  colsPerRow: number[];
  size: number;
  setHoveredTriangle: React.Dispatch<
    React.SetStateAction<TriangleState | null>
  >;
  padding: number[];
}

const HexGridContext = createContext<HexGridContextProps | undefined>(
  undefined
);

export const HexGridProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [triangles, setTriangles] = useState<TriangleState[]>([]);
  const [hoveredTriangle, setHoveredTriangle] = useState<TriangleState | null>(
    null
  );

  const maxCols = Math.max(...colsPerRow);
  const padding = colsPerRow.map((cols) => (maxCols - cols) / 2);

  useEffect(() => {
    const initializeTriangles = () => {
      const triangleStates: TriangleState[] = [];

      for (let row = 0; row < rows; row++) {
        const cols = colsPerRow[row];
        for (let col = 0; col < cols; col++) {
          const triangle: TriangleState = {
            row,
            col,
            isActive: false,
            neighborhoodX: null,
            neighborhoodY: null,
            neighborhoodZ: null,
          };
          triangleStates.push(triangle);
        }
      }

      // Assign neighbors after triangles are initialized
      triangleStates.forEach((triangle) => {
        const neighbors = getNeighbors(triangle, triangleStates);
        triangle.neighborhoodX = neighbors.X;
        triangle.neighborhoodY = neighbors.Y;
        triangle.neighborhoodZ = neighbors.Z;
      });

      setTriangles(triangleStates);
    };

    initializeTriangles();
  }, []);

  const getNeighbors = (
    triangle: TriangleState,
    triangles: TriangleState[]
  ) => {
    const { row, col } = triangle;

    const isUp = (row + col) % 2 === 0;

    const neighbors = {
      X: null as TriangleState | null,
      Y: null as TriangleState | null,
      Z: null as TriangleState | null,
    };

    const neighborOffsets = isUp
      ? [
          [0, -1],
          [0, 1],
          [1, 0],
        ]
      : [
          [0, -1],
          [0, 1],
          [-1, 0],
        ];

    neighborOffsets.forEach(([rowOffset, colOffset], index) => {
      const neighborRow = row + rowOffset;
      const neighborCol = col + colOffset;

      if (neighborRow >= 0 && neighborRow < rows) {
        const neighborCols = colsPerRow[neighborRow];
        if (neighborCol >= 0 && neighborCol < neighborCols) {
          const neighborIndex = triangles.findIndex(
            (triangle) =>
              triangle.row === neighborRow && triangle.col === neighborCol
          );
          neighbors[Object.keys(neighbors)[index] as keyof typeof neighbors] =
            triangles[neighborIndex];
        }
      }
    });

    return neighbors;
  };

  return (
    <HexGridContext.Provider
      value={{
        triangles,
        setTriangles,
        hoveredTriangle,
        setHoveredTriangle,
        colsPerRow,
        size,
        padding,
      }}
    >
      {children}
    </HexGridContext.Provider>
  );
};

export const useHexGrid = () => {
  const context = useContext(HexGridContext);
  if (!context) {
    throw new Error("useHexGrid must be used within a HexGridProvider");
  }
  return context;
};


